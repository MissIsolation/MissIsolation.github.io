<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PAT-A1003 Emergency</title>
    <link href="/2020/02/18/PAT-A1003-Emergency/"/>
    <url>/2020/02/18/PAT-A1003-Emergency/</url>
    
    <content type="html"><![CDATA[<h2 id="A1003-Emergency-（Dijkstra算法）"><a href="#A1003-Emergency-（Dijkstra算法）" class="headerlink" title="A1003 Emergency （Dijkstra算法）"></a>A1003 Emergency （Dijkstra算法）</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p><ul><li>Input Specification:</li></ul><p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: <em>N</em> (≤500) - the number of cities (and the cities are numbered from 0 to <em>N</em>−1), <em>M</em> - the number of roads, <em>C</em>1 and <em>C</em>2 - the cities that you are currently in and that you must save, respectively. The next line contains <em>N</em> integers, where the <em>i</em>-th integer is the number of rescue teams in the <em>i</em>-th city. Then <em>M</em> lines follow, each describes a road with three integers <em>c</em>1, <em>c</em>2 and <em>L</em>, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from <em>C</em>1 to <em>C</em>2.</p><ul><li>Output Specification:</li></ul><p>For each test case, print in one line two numbers: the number of different shortest paths between <em>C</em>1 and <em>C</em>2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p><ul><li>Sample Input:</li></ul><pre><code class="in">5 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1</code></pre><ul><li>Sample Output:</li></ul><pre><code class="out">2 4</code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这道题是经典的Dijkstra算法的应用，在求最短路径的基础上多求了最短路径条数以及最短路径的最大点权，难度不大<del>（本喵太菜所以还是做了好久）</del></p><p>Dijkstra算法的核心就在于在n次遍历中，（1）遍历所有点根据最短路径增加点集，（2）以及增加完点集后遍历所有点来更新c1到达每个点的最短路径*<em>(dis[u] + e[u][v] &lt; dis[v]) *</em>。而本题中还要求的最短路径条数和在此基础上最大救援队数目，在（2）的里面加一个判断即可实现</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, c1, c2;//邻接矩阵（边和边权） 点权  c1到任意一点的最短长度  c1到任意一点的最短路径的条数  c1到任意一点的救援队数目之和int e[500][500], weight[500], dis[500], num[500], w[500];bool visit[510];//作为点的集合const int inf = 999999;int main(){    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;c1, &amp;c2);    for (int i = 0; i &lt; n; i++)    {        scanf(&quot;%d&quot;, &amp;weight[i]);    }    fill(e[0], e[0] + 500 * 500, inf);    fill(dis, dis + 500, inf);    //初始化邻接矩阵    int a, b, c;    for (int i = 0; i &lt; m; i++)    {        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        e[a][b] = e[b][a] = c;    }    //初始化c1    dis[c1] = 0;    w[c1] = weight[c1];    num[c1] = 1;    for (int i = 0; i &lt; n; i++)    {        int u = -1;        int minn = inf;        //遍历所有点，找到到c1路径最短的那个点，加入到点集，直到遍历完所有点为止        for (int j = 0; j &lt; n; j++)        {   //从c1开始            if(visit[j] == false &amp;&amp; dis[j] &lt; minn){                u = j;                minn = dis[j];            }        }        if (u == -1) break;        visit[u] = true;        //在点集加了一个点之后，遍历所有点，更新c1到所有点的最短路径        for (int v = 0; v &lt; n; v++)        {   //如果新点与该点有边            if (visit[v] == false &amp;&amp; e[u][v] != inf)            {   //如果新点到任一点的距离比原来小，就更新dis                if (dis[u] + e[u][v] &lt; dis[v])                {                    dis[v] = dis[u] + e[u][v];                    num[v] = num[u]; //c1到达新点的最短路径条数应该与与他联通的v点相同                    w[v] = w[u] + weight[v];                }                else if (dis[u] + e[u][v] == dis[v])                {                    num[v] = num[v] + num[u];//新点不变，v点加上刚联通的u点的最短路径条数                    if (w[u] + weight[v] &gt; w[v])//如果这条路上的救援队数目更多，就更新                    {                        w[v] = w[u] + weight[v];                    }                }            }        }    }    printf(&quot;%d %d&quot;,num[c2],w[c2]);    return 0;}</code></pre><p>(解题时参考了柳婼大大的代码 有兴趣可以去看一下  -&gt; <a href="https://www.liuchuo.net/" target="_blank" rel="noopener">柳婼のBlog</a>)</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT-A1002 A+B for Polynomials</title>
    <link href="/2020/02/18/PAT-A1002-A-B-for-Polynomials/"/>
    <url>/2020/02/18/PAT-A1002-A-B-for-Polynomials/</url>
    
    <content type="html"><![CDATA[<h2 id="A1002-A-B-for-Polynomials（模拟）"><a href="#A1002-A-B-for-Polynomials（模拟）" class="headerlink" title="A1002 A+B for Polynomials（模拟）"></a>A1002 A+B for Polynomials（模拟）</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>This time, you are supposed to find <em>A</em>+<em>B</em> where <em>A</em> and <em>B</em> are two polynomials.</p><ul><li>Input Specification:</li></ul><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p><p><em>K</em> <em>N</em>1 <em>a<strong>N<em>1 *N</em>2 *a</strong>N<em>2 … <em>N</em></em>K</em> <em>a<strong>N</strong>K</em></p><p>where <em>K</em> is the number of nonzero terms in the polynomial, <em>N**i</em> and <em>a<strong>N</strong>i</em> (<em>i</em>=1,2,⋯,<em>K</em>) are the exponents and coefficients, respectively. It is given that 1≤<em>K</em>≤10，0≤<em>N**K</em>&lt;⋯&lt;<em>N</em>2&lt;<em>N</em>1≤1000.</p><ul><li>Output Specification:</li></ul><p>For each test case you should output the sum of <em>A</em> and <em>B</em> in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p><ul><li>Sample Input:</li></ul><pre><code class="in">2 1 2.4 0 3.22 2 1.5 1 0.5</code></pre><ul><li>Sample Output:</li></ul><pre><code class="out">3 2 1.5 1 2.9 0 3.2</code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>模拟两个多项式相加并输出结果</p><p>用一个数组来存储多项式的系数，输入哪一项的值，就加到哪一项</p><p>遍历一遍得到多项式的个数</p><p>遍历一遍输出多项式</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main(){    float c[1001] = {0};    int m,n,t;    float num;    scanf(&quot;%d&quot;,&amp;m);    for (int i = 0; i &lt; m; i++)    {        scanf(&quot;%d%f&quot;, &amp;t , &amp;num);        c[t] += num;    }    scanf(&quot;%d&quot;,&amp;n);    for (int i = 0; i &lt; n; i++)    {        scanf(&quot;%d%f&quot;,&amp;t,&amp;num);        c[t] += num;    }    int cnt = 0;    for (int i = 0; i &lt; 1001; i++)    {        if (c[i] != 0)        {            cnt++;        }    }    printf(&quot;%d&quot;,cnt);    for (int i = 1000; i &gt;= 0; i--)    {        if (c[i] != 0.0)        {            printf(&quot; %d %.1f&quot;, i, c[i]);        }    }    return 0;}</code></pre><p>(解题时参考了柳婼大大的代码 有兴趣可以去看一下  -&gt; <a href="https://www.liuchuo.net/" target="_blank" rel="noopener">柳婼のBlog</a>)</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT-A1001 A+B Format</title>
    <link href="/2020/02/18/PAT-A1001-A-B-Format/"/>
    <url>/2020/02/18/PAT-A1001-A-B-Format/</url>
    
    <content type="html"><![CDATA[<h2 id="A1001-A-B-Format（字符串处理）"><a href="#A1001-A-B-Format（字符串处理）" class="headerlink" title="A1001 A+B Format（字符串处理）"></a>A1001 A+B Format（字符串处理）</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Calculate <em>a</em>+<em>b</em> and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><ul><li>Input Specification: </li></ul><p>Each input file contains one test case. Each case contains a pair of integers <em>a</em> and <em>b</em> where −106≤<em>a</em>,<em>b</em>≤106. The numbers are separated by a space.</p><ul><li>Output Specification: </li></ul><p>For each test case, you should output the sum of <em>a</em> and <em>b</em> in one line. The sum must be written in the standard format.</p><ul><li>Sample Input:</li></ul><pre><code>-1000000 9</code></pre><ul><li>Sample Output:</li></ul><pre><code>-999,991</code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>将求和问题用字符串进行表示和处理是一种常规做法</p><p>即用 to_String(int) 进行转换</p><p>这一道题的关键在于 何时插入‘，’ 即从前往后输出 而又重后往前数数</p><p>((i + 1) % 3 == len % 3 &amp;&amp; i != len - 1)</p><p>用取余比对的方法来解决这个问题 即通过总长度得出余数 并且保证最后一位不会多输出</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main(){    int a,b;    cin &gt;&gt; a &gt;&gt; b;    string s = to_string(a + b);    int len = s.length();    for (int i = 0; i &lt; len; i++)    {        cout &lt;&lt; s[i];        if (s[i] == &#39;-&#39;) continue;        if ((i + 1) % 3 == len % 3 &amp;&amp; i != len - 1)        {            cout &lt;&lt; &quot;,&quot;;        }    }    return 0;}</code></pre><p>(解题时参考了柳婼大大的代码 有兴趣可以去看一下  -&gt; <a href="https://www.liuchuo.net/" target="_blank" rel="noopener">柳婼のBlog</a>)</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown使用指南</title>
    <link href="/2020/02/14/Markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2020/02/14/Markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="Markdown使用指南"><a href="#Markdown使用指南" class="headerlink" title="Markdown使用指南"></a>Markdown使用指南</h2><h3 id="α-对于文字的操作"><a href="#α-对于文字的操作" class="headerlink" title="α  对于文字的操作"></a>α  对于文字的操作</h3><p>** 中间的部分用粗体表示  如   <strong>我是一只喵</strong></p><p>*  中间的部分表示为斜体 如  <em>本喵想吃小鱼干了</em></p><p>~~ 中间的部分表示为删除线 如  <del>BUG改完了</del></p><p>\ 后加这些特殊符号表示转义，即不产生效果只显示本身符号</p><h3 id="β-对于段落的操作"><a href="#β-对于段落的操作" class="headerlink" title="β  对于段落的操作"></a>β  对于段落的操作</h3><p>1  几级标题就用几个#+标题文字 记得#与文字中间要加一个空格 如 </p><h3 id="看板喵-の-Blog"><a href="#看板喵-の-Blog" class="headerlink" title="看板喵 の Blog"></a>看板喵 の Blog</h3><p>2  &gt; 后的一段会变为引用 如</p><blockquote><p>快起床！BUG要改不完了！</p><p>喵！（炸毛）</p></blockquote><p>3  * 或+ 后的一段会加标识（本喵也不知道这叫什么，反正就这么个东西）</p><p>可以按Tab键进行分级</p><ul><li>喵喵要出去玩~<ul><li>喵喵回来了~</li></ul></li><li>喵喵又要出去玩了~</li></ul><p>4  插入表格</p><p>表格的基本格式</p><blockquote><p>| 喵喵爱吃的菜 | 喵喵不爱吃的零食 |</p><p>| : ————- | : ————- |</p><p>| 小鱼干 | 橘子 |</p><p>| 虾虾  | 干果 |</p></blockquote><p>Command+T 可以插入表格 (Typora)</p><p>5  分割线</p><p>*** 显示分割线</p><hr><p>本喵不喜欢改BUG！</p><hr><h3 id="γ-插入其他元素"><a href="#γ-插入其他元素" class="headerlink" title="γ  插入其他元素"></a>γ  插入其他元素</h3><p>1  插入链接的形式为 [要带链接的文字](网址)  </p><p><a href="https://missisolation.github.io/" target="_blank" rel="noopener">看板喵 の Blog</a></p><p>2  插入图片的形式为 ![图片的名字](图片的地址)</p><p><img src="/Users/apple/Documents/Blog/themes/fluid/source/img/cat.png" srcset="/img/loading.gif" alt="cat"></p><p>（Typora 直接把图片拖进来就可以）</p><p>3  代码框 与数学公式编辑</p><p>代码</p><p>用  `    ` 将代码部分括起来，形成显示代码的区域</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int n, m, c1, c2;int e[510][510], weight[510], dis[510], num[510], w[510];bool visit[510];const int inf = 99999999;int main(){    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;c1, &amp;c2);    for (int i = 0; i &lt; n; i++)    {        scanf(&quot;%d&quot;, &amp;weight[i]);    }        fill(e[0], e[0] + 510 * 510, inf);    return 0;}</code></pre><p>数学公式<br>$$<br>▽²ψ(x,y,z)+(8π²m/h²)[E-U(x,y,z)]ψ(x,y,z)＝0<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>开发工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Me - 日常</title>
    <link href="/2019/11/26/About-Me-%E6%97%A5%E5%B8%B8/"/>
    <url>/2019/11/26/About-Me-%E6%97%A5%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
