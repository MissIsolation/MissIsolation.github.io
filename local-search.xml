<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>考研日志·阶段1 (A preparation log ofPostgraduate Entrance Examination)</title>
    <link href="/2020/09/03/%E8%80%83%E7%A0%94%E6%97%A5%E5%BF%971/"/>
    <url>/2020/09/03/%E8%80%83%E7%A0%94%E6%97%A5%E5%BF%971/</url>
    
    <content type="html"><![CDATA[<p>##Daily Record（stage 1 - week 1）</p><p>——————————————————————————————</p><p>###week plan（9.03-9.10）</p><p>数学：完成高数前5章（第五章可以没全部完成）的再复习以及基础篇的题目和整理。完成线性代数至少前5章的内容和课本例题（下周基础收尾）</p><p>（数学主要解决1 基础知识、定理的理解扎实掌握和灵活运用以及2 各种基础题型和解题方法的掌握以及3 熟练解题的能力的锻炼）</p><p>专业课：这一周把数据结构彻底搞完（编程实现要做，但是后面的编程大题不用全做），可以开始看计组了，至少看上两章（等中旬出来简章以后决定一下学校，到底是科大，复旦，还是报其他学校），然后再做专业课计划</p><p>（专业课要防止之后忘记的问题，要学的精通一点，并且做好笔记关键点，让之后二轮一看就可以想起来，代码也要写，可以熟练）</p><p>英语：每天完成3篇阅读的精读以及300以上的单词和一个unit的背诵，看完一半唐迟的阅读课（直接上强化），每天复习一下语法的知识（笔记本上），每天练一下字</p><p>（英语要突破阅读，要做到阅读和答题无障碍，培养题感）</p><p>政治：每天中午晚上两倍速看徐涛的课，2倍速一个月看完，然后等政治资料来了以后开始看，每天一个小时</p><p>——————————————————————————————</p><p>###2020.09.03</p><p>将所有资料准备齐全，将所有要用的书分门别类放好，方便取用</p><p>打印好招聘简章，准备好所有材料和说辞，并且和张经理说好，并将信息发过去（打一个电话，然后准备好整个环节，下午将材料送过去）（完成）</p><p>将week plan制定完毕，并定调成功，把自身置入那个状态和身份</p><p>进入备战状态，测试好所有的任务和时间属性，吹响战争的号角（完成）</p><p>完成数据结构第三章和第四章的学习（明天完成整理以及这一部分的代码）</p><p>完成数学基础复习和刷题模式的确定（从明天开始狂刷）</p><p>完成3篇英语阅读精读以及300单词和一个unit以及语法复习</p><p>重新搞一下博客，然后每天更新一下，就这个日志，顺便可以刷一下github提交（过两天把之前做的项目都搞到github上去，定期push一下）</p><p>常规  饮食以及洗护和宿舍循环（）</p><p>常规  日常锻炼+夜跑3KM（）</p><p>常规  11：10分收拾完毕上床睡觉（）</p><p>日志：</p><p>——————————————————————————————</p><p>###2020.09.04</p>]]></content>
    
    
    
    <tags>
      
      <tag>考研准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研日志·阶段0 (A preparation log ofPostgraduate Entrance Examination)</title>
    <link href="/2020/09/03/%E8%80%83%E7%A0%94%E6%97%A5%E5%BF%970/"/>
    <url>/2020/09/03/%E8%80%83%E7%A0%94%E6%97%A5%E5%BF%970/</url>
    
    <content type="html"><![CDATA[<h2 id="Daily-Record"><a href="#Daily-Record" class="headerlink" title="Daily Record"></a>Daily Record</h2><p>###2020.08.24</p><p>完成 大部分资料的回收</p><p>完成 面向对象的第一章的整体复习</p><p>完成 编译原理绪论和词法分析器的整体复习（注意看一些概念的介绍和题目）</p><p>完成 政治的计划和资源的整合，做好这十天的规划，从明天开始正式执行渐进计划</p><p>完成  每日的单词计划和英语阅读精读</p><p>（数学和专业课  今天暂时不做）</p><p>经验：在晚上饭后6：30到8：30这个时间段会很累，表现特征为注意力不集中，头部发胀，有种凝固的感觉，坚持1-2小时候就会有明显好转，以后可以多加以观察，如果存在，考虑如何避免，或者将一部分适合的任务分配到这个时间段</p><p>###2020.08.25</p><p>8：36开始学习</p><p>编译原理 词法分析剩下的部分和语法分析（完成）</p><p>移动应用开发 3个lesson（未完成）</p><p>英语 300个单词  （完成）</p><p>数学  一节线代的课程  做完第一章的题并且进行整理（未完成）</p><p>完成最近所有的写作素材整理（完成）</p><p>经验：昨天睡得太晚，导致起得太晚，耽误了一个半小时的复习时间，以后争取熄灯就睡觉，早睡早起规律作息</p><p>不要在一些细节上耽误太久，先高效完成大部分的任务，在集中精力把细节上不理解的地方搞定，不要试图一遍把所有细节全部掌握，那样要花费成倍的时间和精力，要达到一个程度和次数的平衡，以追求最大的效率。</p><p>只要花时间去做了，就要保证效率，低效做事不如不做！</p><p>###2020.08.26</p><p>早上7：00左右出发，取完快递到自习室复习，9：00开始，吃早饭加收拾加取快递总共两小时（相当于锻炼了）（完成）</p><p>完成编译原理所有的复习，包括答疑后的补充（之后每天做题熟练，理解背诵）（完成）</p><p>完成2个移动应用开发的lesson（删除）</p><p>完成面向对象第二章的复习（删除）</p><p>完成专业课 数据结构 2、3章的学习与整理（未完成）</p><p>完成英语300单词（完成）</p><p>整理完当下要用的衣服，完成正向循环（完成）</p><p>###2020.08.27</p><p>完成  收拾柜子，检查袋子，装床帘，搞个老鼠贴，拿快递，屋内完全清理（完成）</p><p>完成  面向对象ch02 ch03 以及对应的材料的理解记忆（完成部分）</p><p>完成  移动应用开发3个以上lesson的复习（完成）</p><p>完成  编译原理，一半细节点的补充，然后列写可能考的每种计算并都做一个题（未完成）</p><p>完成  数据结构2、3章的整理（未完成）</p><p>完成  离散复习第一章把第二张矩阵的视频和课本看完（未完成）</p><p>完成  英语300单词（完成）</p><p>经验：今天精神状态不好，很多无意义的时间浪费，以后要避免</p><p>###2020.08.28</p><p>完成  面向对象的4、5、6章的画图和作业的一次背诵（完成）</p><p>完成  移动应用开发3个lesson（未完成）</p><p>完成  编译原理剩下的遗留问题，把所有计算问题列写，然后练习整合，并且把C卷做完（完成）</p><p>完成  数据结构2、3章剩下的整理（未完成）</p><p>完成  线性代数矩阵部分的课程和整理（未完成）</p><p>完成  英语300单词（完成）</p><p>日志：今天感到非常非常疲倦，头非常涨，有种晕晕的感觉，应该是这几天复习强度太大导致的。</p><p>根据回来这几天的经验，可以判断，在高强度复习的状态下，6-7天的高强度复习就会使你达到一个疲惫的临界点，优势就会不由自主的分散精力。所以，之后的复习过程中我们建议，每周拿出半天进行休息和调整，并整理这一周的复习和教训，并且指定下一周的计划。整个“黑荆棘”计划就是一个大型战役，每一周都是一场局部遭遇战，我们要每一次都拼尽全力，逐步建立战略优势，最终获得战役的胜利。</p><p>###2020.08.29</p><p>完成  编译原理最后复习（完成）</p><p>完成  编译原理考试（完成）</p><p>完成  移动应用开发3个lesson（完成）</p><p>完成  英语300单词（未完成  只背了100）</p><p>日志：感觉有点精疲力尽。以后要保证  规律作息  合理饮食  以及适当运动  和  充分学习，这四个方面保证你的身心健康，再在各个细节护理一下，把自己调整到一个比较好的状态。这是生理上的辅助计划（和精神上的辅助计划相对应）</p><p>以后每天晚上去跑步，每天按时睡觉。看他们的学习状态和进度也是一般，没有拿出全力每时每刻复习，也没有一种拼尽一切的态度，进度也没有很快。只要你拿出全部时间精力，毫不松懈拼尽一切的态度，保证身体和精神，坚持这四个月，你肯定复习的可以比他们好，可以考上你想要去的地方</p><p>###2020.08.30</p><p>完成  11：10前收拾完毕 上床睡觉（未完成）</p><p>完成  晚上跑步3KM以及早中晚各30个俯卧撑（跑步未完成）</p><p>完成  面向对象的作业的背诵（2遍  务必记熟）以及填空部分的背诵和画图部分的复习（取看看之前画的图）</p><p>完成  移动应用开发3个lesson（未完成）</p><p>完成  数据结构的2、3章的复习和整理（有条件可以看一下第四章）（第三章未完成）</p><p>完成  高数第一章的题目和整理（完全），把一二章的公式抄录一下（未完成）</p><p>完成  300英语单词背诵（完成）</p><p>附加  矩阵部分的视频和练习（未完成的部分可以明天继续）</p><p>日志：经过测试，早上吃饭到图书馆这段路可以复习100个左右的单词（背不完的可以到图书馆背完再开始其他任务）</p><p>一定要早睡，今天睡眠不足导致早上起来到图书馆效率非常低，都背不下去，所以一定要保证充足的睡眠和睡眠质量</p><p>早晨如果是在状态不好，可以喝杯咖啡（但尽量不要，摄取咖啡因还是有风险的）</p><p>经过测试，中午回去加上下午回到图书馆至少可以复习100个以上的单词（背不完的可以到图书馆背完再开始其他任务）</p><p>经过测试，在正常条件下一分钟可以背诵2.14个单词，所以一般来说，背诵100个新单词需要大概45分钟左右</p><p>所以，一天最大容量可以复习400左右的单词，可以200新的，200旧的，也可以100新的，300旧的</p><p>2020.08.31</p><p>考试  面向对象的最终复习（完成）</p><p>考试  面向对象考试（完成）</p><p>考试  3个移动应用开发lesson（未完成）</p><p>考研  数据结构第三章的学习整理，第四章的复习（未完成）</p><p>考研  完成高数第一章的再复习和基础篇的练习（整理明天做）（未完成）</p><p>考研  完成政治材料的准备和计划的制定（未完成）</p><p>考研  完成300单词背诵（未完成  只背了200）</p><p>杂项  四个快递代取，两个中午，两个下午，明天取完（完成）</p><p>常规  日常锻炼+夜跑3KM+水果（未完成）</p><p>常规  11：10分收拾完毕上床睡觉（完成）</p><p>日志：今天状态非常不好，尤其是到了晚上，直接什么都做不了，所以一定要早睡早起，保证精神充沛</p><p>2020.09.01</p><p>考试  移动应用开发看完一遍，然后做一下梳理</p><p>考研  数据结构第三章的学习整理，第四章的复习（整理未完成  学习完成）</p><p>考研  完成高数第一章的再复习和基础篇的练习（整理明天做）</p><p>考研  完成政治材料的准备和计划的制定</p><p>考研  完成300单词背诵</p><p>杂项  四个快递代取，两个中午，两个下午，明天取完（完成）</p><p>常规  日常锻炼+夜跑3KM+水果</p><p>常规  11：10分收拾完毕上床睡觉</p><p>2020.9.2</p><p>完成移动应用开发最终复习（完成）</p><p>完成移动应用开发考试（完成）</p><p>完成宿舍的最终收拾打理，可以进入循环（完成）</p><p>将所有资料准备齐全，将所有要用的书分门别类放好，方便取用（未完成）</p><p>打印好招聘简章，准备好所有材料和说辞，并且和张经理说好，并将信息发过去（明早打一个电话，然后准备好整个环节，下午将材料送过去）</p><p>确定好目标和信息渠道，制定好黑荆棘整体计划和第一阶段方案，确定执行的策略并且保证军队化执行，确保计划顺利推进（完成）</p><p>考研  完成300单词背诵（完成）</p><p>常规  日常锻炼+夜跑3KM（完成）</p><p>作为一个阶段的结束可以稍微休息一下（完成）</p><p>常规  11：10分收拾完毕上床睡觉（未完成  12：10）</p><p>——————————————————————————————</p>]]></content>
    
    
    
    <tags>
      
      <tag>考研准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研计划(Postgraduate Entrance Examination Scheme)</title>
    <link href="/2020/09/03/%E8%80%83%E7%A0%94%E8%AE%A1%E5%88%92/"/>
    <url>/2020/09/03/%E8%80%83%E7%A0%94%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>##考研计划（9月至初试）</p><p>###暂定阶段计划（可根据实际情况变化）</p><p>###Stage 1 （8.24 - 9.16）</p><p>###8.24-9.2（10 Days）</p><p>将考试的三个科目复习到位，9.2之前完成所有考试并且通过</p><p>在复习考试科目的基础上，进入状态，剩余时间复习考研科目</p><p>（完成基础部分高数的前三章和知识点梳理，线代部分基础课看完，题目大致做完）</p><p>（英语开始背单词，app和单词书一起用。这个阶段主要把阅读搞定，可以每天精读一篇，并且复习一下语法）</p><p>（专业课方面争取把数据结构过一遍，题目可以先不做大题）</p><p>（政治的资料搞定，从9月开始复习，把计划列好）</p><p>###9.2-9.16（14Days）</p><p>开始全面进入备考状态，并结束数学的基础阶段和英语的阅读阶段</p><p>（高数完成基础阶段剩下的部分并且整理好错题，线代完成基础部分剩下的）</p><p>（英语完成所有阅读精读并且背完一遍单词，完成所有阅读课程，清扫阅读的障碍）</p><p>（专业课完成数据结构未完成的部分以及计组的复习和操作系统的复习）</p><p>（政治每天一小时左右+吃饭的时候看网课）</p><p>###Stage 2（9.16-10.15 30 Days）</p><p>完成强化阶段</p><p>（数学把强化班的课程看完，并且将强化部分的题目完成，这样就把基础打牢了。线代将强化班看完，完成对应题目的整理）</p><p>（英语继续背一遍单词，这个阶段一方面是反复阅读，另一方面准备小三门和作文，英语把整个体系打通了）</p><p>（专业课方面把计网看完，然后把来第二遍，这一遍就要把所有难点和题目刷完，不留下死角）</p><p>（政治看网课，刷题）</p><p>###Stage 3（10.15 - 11.14）</p><p>开始入手真题</p><p>英语继续背单词，准备作文，重复真题（时间可减少）</p><p>数学和专业课上真题，一天一套，当天整理完（留下用来模拟的）</p><p>数学入手一本其他资料，查缺补漏</p><p>专业课把第二轮结束，反向查找不会的点并补全</p><p>政治……</p><p>###Stage 4（11.14 - 12.14）</p><p>最后一轮</p><p>数学和专业课开始做模拟卷，两天一套，并且主要是查缺补漏</p><p>数学把之前的卷子，题目再练一遍</p><p>专业课开始第三轮，把不会的彻底扫完</p><p>英语继续 单词 卷子 开始模拟</p><p>政治……</p><p>Stage Final  一周时间</p><p>这一周保持手感，把所有材料再看一遍，然后走上考场</p><p>——————————————————————————</p><p>###日程安排</p><p>6：10  起床  吃饭洗漱去图书馆（路上就开始背单词）</p><p>7：00  到图书馆正式开始复习 </p><p>12：00  离开图书馆去打饭（早一点点也可以，避免排队）</p><p>12：00-1：00-2：00  吃饭洗漱 可以看看视频放松下（可以看政治课）午休</p><p>2：00  到达图书馆开始复习</p><p>5：30  去打饭  吃饭洗漱  看视频放松下（可以看政治课）</p><p>6：30  到图书馆开始复习</p><p>9：30  回到宿舍，换衣服去跑步，然后回来洗澡洗衣服</p><p>10：30  背一下单词，做一下总结，11：00左右洗漱，睡觉</p><p>11：10  必上床睡觉（除特殊情况，每周最多只有一次）  一定养成习惯，规律作息！！！</p><p>（所有路上都可以背单词，或者和同学聊一下天）</p><p>————————————————————————————</p><p>###</p>]]></content>
    
    
    
    <tags>
      
      <tag>考研准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目开发踩坑日志(+1)</title>
    <link href="/2020/02/24/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E6%97%A5%E5%BF%97-1/"/>
    <url>/2020/02/24/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E6%97%A5%E5%BF%97-1/</url>
    
    <content type="html"><![CDATA[<h2 id="项目开发踩坑日志-1"><a href="#项目开发踩坑日志-1" class="headerlink" title="项目开发踩坑日志(+1)"></a>项目开发踩坑日志(+1)</h2><p>十分不情愿的开始了项目开发的工作……</p><h3 id="研究生论文送审平台（学院专家管理模块）"><a href="#研究生论文送审平台（学院专家管理模块）" class="headerlink" title="研究生论文送审平台（学院专家管理模块）"></a>研究生论文送审平台（学院专家管理模块）</h3><p>花费了完全三天时间完成 项目的 理解分析  代码编写  测试修改并最终验收</p><p>主要功能工作包括 1 基础功能  2 三个附加功能 3 权限与测试</p><h3 id="1-基础功能开放踩坑"><a href="#1-基础功能开放踩坑" class="headerlink" title="1 基础功能开放踩坑"></a>1 基础功能开放踩坑</h3><p>表单配置</p><p>代码生成</p><p>权限配置</p><p>grid选择框（这个是真的坑，要从mapper一路改到前端）</p><ul><li>前端的属性通过封装的直接去别的模块的mapper去取，千万别写错路径</li><li>后端mapper保存的时候也是，注意要改 别名 leftjoin findlist insert 以及update</li></ul><p>一些细节的修改</p><h3 id="2-三个附加功能"><a href="#2-三个附加功能" class="headerlink" title="2 三个附加功能"></a>2 三个附加功能</h3><p>A 根据登录账号秘书身份筛选数据</p><p>B 新增专家的时候根据账号信息去查找相关秘书的信息，填充秘书代码以及高校代码+学院代码字段</p><p>C 在新增专家时，在sys_userz中自动生成一个可登陆的专家用户，并指定权限与身份</p><h3 id="3-权限与测试"><a href="#3-权限与测试" class="headerlink" title="3 权限与测试"></a>3 权限与测试</h3><p>测试碰到了许许多多数据库字段以及权限相关的报错，都一一解决了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个项目坑的地方在于，一茬一茬的人写，留下了一路的坑，有很多模块很多人重复开发过，实际情况与设计文档严重不符，存在各种各样奇奇怪怪的表和模块，都不知道要加的这个模块的数据要和哪些模块做关联，其他模块又是怎么工作的，只能自己去看代码理解，估摸着写，估摸着测试，碰到坑就重新写，磕磕绊绊总算是搞定了。模块本身从功能上来说并不是太难，主要是项目管控和开发测试的管理做的太差，文档留的太少，很多都是口头约定然后修改的，为后续模块开发带来了大量困难。从这种事件中可以看出，一个好的工程管理的重要性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习算法的一点思路</title>
    <link href="/2020/02/19/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%B7%AF/"/>
    <url>/2020/02/19/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="关于学习算法的一点思考"><a href="#关于学习算法的一点思考" class="headerlink" title="关于学习算法的一点思考"></a>关于学习算法的一点思考</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><hr><p>作为一个技术狗，数据结构和算法的重要性是毋庸置疑的<del>（比如说像我一样在项目里写各种鸡肋实现方式的时候，你就会体会到这玩意的重要性了）</del>。所以，痛定思痛，决定扎扎实实的把这一块掌握起来，包括但不限于算法的原理，实现方式以及各种应用。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><hr><p>对于算法的学习，打算从两条线入手，<strong>自顶向下和自底向上</strong>。自顶向下就是从数据结构和算法的书籍入手，一点一点啃，逐步建立起算法的知识体系，即有一个完整而清晰地框架，每个算法的原理，实现方式，以及各个算法之间的联系与区别。而自底向上则是从算法题入手，无论是在LeetCode也好，PAT也好，通过解题来学习算法的应用，思路，从而可以在开发中熟练应用各种算法的知识<del>（当然，从功利角度来说，无论是考研复试还是找工作，算法题是你永远绕不开的坎）</del>。</p><p><strong>而对于算法的训练，应当成为每一个开发者的日常习惯，就如同吃饭喝水一样。</strong>只有日复一日的持续学习，思考，编码过程中，才能将一项技能彻底掌握。当然，并不是说要求每天成小时的使劲做，而是细水长流，每天可以来上几道题，什么时候做都可以，早上起来，午饭后，甚至排队，<del>蹲坑</del>的时候都可以想，可以做，让它成为你生活的一部分，一个习惯。基于以上思考，<strong>计划两天学习一章的算法，每天两道PAT，两道LeetCode（PAT平推，LeetCode每周选一种类型进行刷题）</strong>。</p><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><hr><p>而刷算法的思路有了，再说一下方式。</p><p>对于自顶向下来说，相当于课程的学习，逐步推进，没有什么特别要说的，按照三个步骤</p><ul><li><strong>（1）根据书来学习和理解算法</strong></li><li><strong>（2）将算法的原理和思路整理在本子上</strong></li><li><strong>（3）独立的将这个算法及相关编码实现</strong></li></ul><p>对于自底向上，要稍微复杂一点，大致为四个步骤</p><ul><li><p><strong>（1）首先分析问题，确定题目的需求（尤其英文题目，一定要看清楚），分析思路，选择对应的算法</strong></p></li><li><p><strong>（2）查找相应的数据结构与算法，进行学习记录，达到可以独立实现的程度（如果是兔系刷题方式可合并到（3）后）</strong></p></li><li><p><strong>（3）编码实现，有两种方式，第一个是兔系刷题方式</strong></p><ul><li><strong>（a）先去看大佬们的答案，理解代码，整理思路</strong></li><li><strong>（b）然后自己独立的实现一遍，注意比对差距并完善</strong></li></ul><p>​         <strong>另一种是龟系刷题方式</strong></p><ul><li><strong>（a）不论多难，自己来写<del>（实在不会看看也可）</del></strong></li><li><strong>（b）再找大佬的解答不断对比，找差距，完善自己的代码和意识</strong></li></ul></li><li><p><strong>（4）整理题目，包括分析，思路，编码过程等等，整理成Markdown形式，上传到自己的Blog</strong></p><p>（对于具体如何刷题，可以进一步参考知乎大佬们的回答 -&gt; <a href="https://www.zhihu.com/question/280279208/answer/499663699" target="_blank" rel="noopener">胖君</a>）</p></li></ul><p>以上，希望自己可以按照这个思路坚持下来，有所收获。</p><blockquote><p>（1/6 β Project）</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT-A1003 Emergency</title>
    <link href="/2020/02/18/PAT-A1003-Emergency/"/>
    <url>/2020/02/18/PAT-A1003-Emergency/</url>
    
    <content type="html"><![CDATA[<h2 id="A1003-Emergency-（Dijkstra算法）"><a href="#A1003-Emergency-（Dijkstra算法）" class="headerlink" title="A1003 Emergency （Dijkstra算法）"></a>A1003 Emergency （Dijkstra算法）</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p><ul><li>Input Specification:</li></ul><p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: <em>N</em> (≤500) - the number of cities (and the cities are numbered from 0 to <em>N</em>−1), <em>M</em> - the number of roads, <em>C</em>1 and <em>C</em>2 - the cities that you are currently in and that you must save, respectively. The next line contains <em>N</em> integers, where the <em>i</em>-th integer is the number of rescue teams in the <em>i</em>-th city. Then <em>M</em> lines follow, each describes a road with three integers <em>c</em>1, <em>c</em>2 and <em>L</em>, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from <em>C</em>1 to <em>C</em>2.</p><ul><li>Output Specification:</li></ul><p>For each test case, print in one line two numbers: the number of different shortest paths between <em>C</em>1 and <em>C</em>2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p><ul><li>Sample Input:</li></ul><pre><code class="in">5 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1</code></pre><ul><li>Sample Output:</li></ul><pre><code class="out">2 4</code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这道题是经典的Dijkstra算法的应用，在求最短路径的基础上多求了最短路径条数以及最短路径的最大点权，难度不大<del>（本喵太菜所以还是做了好久）</del></p><p>Dijkstra算法的核心就在于在n次遍历中，（1）遍历所有点根据最短路径增加点集，（2）以及增加完点集后遍历所有点来更新c1到达每个点的最短路径*<em>(dis[u] + e[u][v] &lt; dis[v]) *</em>。而本题中还要求的最短路径条数和在此基础上最大救援队数目，在（2）的里面加一个判断即可实现</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, c1, c2;//邻接矩阵（边和边权） 点权  c1到任意一点的最短长度  c1到任意一点的最短路径的条数  c1到任意一点的救援队数目之和int e[500][500], weight[500], dis[500], num[500], w[500];bool visit[510];//作为点的集合const int inf = 999999;int main(){    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;c1, &amp;c2);    for (int i = 0; i &lt; n; i++)    {        scanf(&quot;%d&quot;, &amp;weight[i]);    }    fill(e[0], e[0] + 500 * 500, inf);    fill(dis, dis + 500, inf);    //初始化邻接矩阵    int a, b, c;    for (int i = 0; i &lt; m; i++)    {        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        e[a][b] = e[b][a] = c;    }    //初始化c1    dis[c1] = 0;    w[c1] = weight[c1];    num[c1] = 1;    for (int i = 0; i &lt; n; i++)    {        int u = -1;        int minn = inf;        //遍历所有点，找到到c1路径最短的那个点，加入到点集，直到遍历完所有点为止        for (int j = 0; j &lt; n; j++)        {   //从c1开始            if(visit[j] == false &amp;&amp; dis[j] &lt; minn){                u = j;                minn = dis[j];            }        }        if (u == -1) break;        visit[u] = true;        //在点集加了一个点之后，遍历所有点，更新c1到所有点的最短路径        for (int v = 0; v &lt; n; v++)        {   //如果新点与该点有边            if (visit[v] == false &amp;&amp; e[u][v] != inf)            {   //如果新点到任一点的距离比原来小，就更新dis                if (dis[u] + e[u][v] &lt; dis[v])                {                    dis[v] = dis[u] + e[u][v];                    num[v] = num[u]; //c1到达新点的最短路径条数应该与与他联通的v点相同                    w[v] = w[u] + weight[v];                }                else if (dis[u] + e[u][v] == dis[v])                {                    num[v] = num[v] + num[u];//新点不变，v点加上刚联通的u点的最短路径条数                    if (w[u] + weight[v] &gt; w[v])//如果这条路上的救援队数目更多，就更新                    {                        w[v] = w[u] + weight[v];                    }                }            }        }    }    printf(&quot;%d %d&quot;,num[c2],w[c2]);    return 0;}</code></pre><p>(解题时参考了柳婼大大的代码 有兴趣可以去看一下  -&gt; <a href="https://www.liuchuo.net/" target="_blank" rel="noopener">柳婼のBlog</a>)</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT-A1002 A+B for Polynomials</title>
    <link href="/2020/02/18/PAT-A1002-A-B-for-Polynomials/"/>
    <url>/2020/02/18/PAT-A1002-A-B-for-Polynomials/</url>
    
    <content type="html"><![CDATA[<h2 id="A1002-A-B-for-Polynomials（模拟）"><a href="#A1002-A-B-for-Polynomials（模拟）" class="headerlink" title="A1002 A+B for Polynomials（模拟）"></a>A1002 A+B for Polynomials（模拟）</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>This time, you are supposed to find <em>A</em>+<em>B</em> where <em>A</em> and <em>B</em> are two polynomials.</p><ul><li>Input Specification:</li></ul><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p><p><em>K</em> <em>N</em>1 <em>a<strong>N<em>1 *N</em>2 *a</strong>N<em>2 … <em>N</em></em>K</em> <em>a<strong>N</strong>K</em></p><p>where <em>K</em> is the number of nonzero terms in the polynomial, <em>N**i</em> and <em>a<strong>N</strong>i</em> (<em>i</em>=1,2,⋯,<em>K</em>) are the exponents and coefficients, respectively. It is given that 1≤<em>K</em>≤10，0≤<em>N**K</em>&lt;⋯&lt;<em>N</em>2&lt;<em>N</em>1≤1000.</p><ul><li>Output Specification:</li></ul><p>For each test case you should output the sum of <em>A</em> and <em>B</em> in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p><ul><li>Sample Input:</li></ul><pre><code class="in">2 1 2.4 0 3.22 2 1.5 1 0.5</code></pre><ul><li>Sample Output:</li></ul><pre><code class="out">3 2 1.5 1 2.9 0 3.2</code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>模拟两个多项式相加并输出结果</p><p>用一个数组来存储多项式的系数，输入哪一项的值，就加到哪一项</p><p>遍历一遍得到多项式的个数</p><p>遍历一遍输出多项式</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main(){    float c[1001] = {0};    int m,n,t;    float num;    scanf(&quot;%d&quot;,&amp;m);    for (int i = 0; i &lt; m; i++)    {        scanf(&quot;%d%f&quot;, &amp;t , &amp;num);        c[t] += num;    }    scanf(&quot;%d&quot;,&amp;n);    for (int i = 0; i &lt; n; i++)    {        scanf(&quot;%d%f&quot;,&amp;t,&amp;num);        c[t] += num;    }    int cnt = 0;    for (int i = 0; i &lt; 1001; i++)    {        if (c[i] != 0)        {            cnt++;        }    }    printf(&quot;%d&quot;,cnt);    for (int i = 1000; i &gt;= 0; i--)    {        if (c[i] != 0.0)        {            printf(&quot; %d %.1f&quot;, i, c[i]);        }    }    return 0;}</code></pre><p>(解题时参考了柳婼大大的代码 有兴趣可以去看一下  -&gt; <a href="https://www.liuchuo.net/" target="_blank" rel="noopener">柳婼のBlog</a>)</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT-A1001 A+B Format</title>
    <link href="/2020/02/18/PAT-A1001-A-B-Format/"/>
    <url>/2020/02/18/PAT-A1001-A-B-Format/</url>
    
    <content type="html"><![CDATA[<h2 id="A1001-A-B-Format（字符串处理）"><a href="#A1001-A-B-Format（字符串处理）" class="headerlink" title="A1001 A+B Format（字符串处理）"></a>A1001 A+B Format（字符串处理）</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Calculate <em>a</em>+<em>b</em> and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><ul><li>Input Specification: </li></ul><p>Each input file contains one test case. Each case contains a pair of integers <em>a</em> and <em>b</em> where −106≤<em>a</em>,<em>b</em>≤106. The numbers are separated by a space.</p><ul><li>Output Specification: </li></ul><p>For each test case, you should output the sum of <em>a</em> and <em>b</em> in one line. The sum must be written in the standard format.</p><ul><li>Sample Input:</li></ul><pre><code>-1000000 9</code></pre><ul><li>Sample Output:</li></ul><pre><code>-999,991</code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>将求和问题用字符串进行表示和处理是一种常规做法</p><p>即用 to_String(int) 进行转换</p><p>这一道题的关键在于 何时插入‘，’ 即从前往后输出 而又重后往前数数</p><p>((i + 1) % 3 == len % 3 &amp;&amp; i != len - 1)</p><p>用取余比对的方法来解决这个问题 即通过总长度得出余数 并且保证最后一位不会多输出</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main(){    int a,b;    cin &gt;&gt; a &gt;&gt; b;    string s = to_string(a + b);    int len = s.length();    for (int i = 0; i &lt; len; i++)    {        cout &lt;&lt; s[i];        if (s[i] == &#39;-&#39;) continue;        if ((i + 1) % 3 == len % 3 &amp;&amp; i != len - 1)        {            cout &lt;&lt; &quot;,&quot;;        }    }    return 0;}</code></pre><p>(解题时参考了柳婼大大的代码 有兴趣可以去看一下  -&gt; <a href="https://www.liuchuo.net/" target="_blank" rel="noopener">柳婼のBlog</a>)</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown使用指南</title>
    <link href="/2020/02/14/Markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2020/02/14/Markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="Markdown使用指南"><a href="#Markdown使用指南" class="headerlink" title="Markdown使用指南"></a>Markdown使用指南</h2><h3 id="α-对于文字的操作"><a href="#α-对于文字的操作" class="headerlink" title="α  对于文字的操作"></a>α  对于文字的操作</h3><p>** 中间的部分用粗体表示  如   <strong>我是一只喵</strong></p><p>*  中间的部分表示为斜体 如  <em>本喵想吃小鱼干了</em></p><p>~~ 中间的部分表示为删除线 如  <del>BUG改完了</del></p><p>\ 后加这些特殊符号表示转义，即不产生效果只显示本身符号</p><h3 id="β-对于段落的操作"><a href="#β-对于段落的操作" class="headerlink" title="β  对于段落的操作"></a>β  对于段落的操作</h3><p>1  几级标题就用几个#+标题文字 记得#与文字中间要加一个空格 如 </p><h3 id="看板喵-の-Blog"><a href="#看板喵-の-Blog" class="headerlink" title="看板喵 の Blog"></a>看板喵 の Blog</h3><p>2  &gt; 后的一段会变为引用 如</p><blockquote><p>快起床！BUG要改不完了！</p><p>喵！（炸毛）</p></blockquote><p>3  * 或+ 后的一段会加标识（本喵也不知道这叫什么，反正就这么个东西）</p><p>可以按Tab键进行分级</p><ul><li>喵喵要出去玩~<ul><li>喵喵回来了~</li></ul></li><li>喵喵又要出去玩了~</li></ul><p>4  插入表格</p><p>表格的基本格式</p><blockquote><p>| 喵喵爱吃的菜 | 喵喵不爱吃的零食 |</p><p>| : ————- | : ————- |</p><p>| 小鱼干 | 橘子 |</p><p>| 虾虾  | 干果 |</p></blockquote><p>Command+T 可以插入表格 (Typora)</p><p>5  分割线</p><p>*** 显示分割线</p><hr><p>本喵不喜欢改BUG！</p><hr><h3 id="γ-插入其他元素"><a href="#γ-插入其他元素" class="headerlink" title="γ  插入其他元素"></a>γ  插入其他元素</h3><p>1  插入链接的形式为 [要带链接的文字](网址)  </p><p><a href="https://missisolation.github.io/" target="_blank" rel="noopener">看板喵 の Blog</a></p><p>2  插入图片的形式为 ![图片的名字](图片的地址)</p><p><img src="/Users/apple/Documents/Blog/themes/fluid/source/img/cat.png" srcset="/img/loading.gif" alt="cat"></p><p>（Typora 直接把图片拖进来就可以）</p><p>3  代码框 与数学公式编辑</p><p>代码</p><p>用  `    ` 将代码部分括起来，形成显示代码的区域</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int n, m, c1, c2;int e[510][510], weight[510], dis[510], num[510], w[510];bool visit[510];const int inf = 99999999;int main(){    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;c1, &amp;c2);    for (int i = 0; i &lt; n; i++)    {        scanf(&quot;%d&quot;, &amp;weight[i]);    }        fill(e[0], e[0] + 510 * 510, inf);    return 0;}</code></pre><p>数学公式<br>$$<br>▽²ψ(x,y,z)+(8π²m/h²)[E-U(x,y,z)]ψ(x,y,z)＝0<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>开发工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Me - 日常</title>
    <link href="/2019/11/26/About-Me-%E6%97%A5%E5%B8%B8/"/>
    <url>/2019/11/26/About-Me-%E6%97%A5%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>The game has begun . . .</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
