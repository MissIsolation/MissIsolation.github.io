<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java集合框架</title>
    <link href="/2021/03/25/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/03/25/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java其他特性</title>
    <link href="/2021/03/02/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <url>/2021/03/02/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="Java其它特性"><a href="#Java其它特性" class="headerlink" title="Java其它特性"></a>Java其它特性</h3><hr><h3 id="1-关于JDK、JRE、JVM和Java编译器及Java解释器"><a href="#1-关于JDK、JRE、JVM和Java编译器及Java解释器" class="headerlink" title="1 关于JDK、JRE、JVM和Java编译器及Java解释器"></a>1 关于JDK、JRE、JVM和Java编译器及Java解释器</h3><p>JDK是Java的开发工具包（SDK），提供了开发环境（编译器javac等工具，用于将java文件编译为class文件）以及运行环境JRE（JVM和Runtime辅助包，用于解析class文件使其得到运行）</p><p>JRE是Java运行环境，包含JVM和核心类库（的class文件）与支持文件（只要装了JRE就可以运行Java文件）</p><p>JVM：一种能够运行Java字节码（Java bytecode）的虚拟机。</p><p>字节码：字节码是已经经过编译，但与特定机器码无关，需要解释器转译后才能成为机器码的中间代码。</p><p>JVM：JVM有自己完善的硬件架构，如处理器、堆栈（Stack）、寄存器等，还具有相应的指令系统（字节码就是一种指令格式）。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。JVM是Java平台无关的基础。<strong>JVM负责运行字节码：JVM把每一条要执行的字节码交给解释器，翻译成对应的机器码，然后由解释器执行</strong>。JVM解释执行字节码文件就是<strong>JVM操作Java解释器进行解释执行字节码文件的过程</strong>。</p><p>Java编译器：将Java源文件（.java文件）编译成字节码文件（.class文件，是特殊的二进制文件，二进制字节码文件），这种字节码就是JVM的“机器语言”。javac.exe可以简单看成是Java编译器。</p><p>Java解释器：是JVM的一部分。Java解释器用来解释执行Java编译器编译后的程序。java.exe可以简单看成是Java解释器。</p><p>即时编译(Just-in-time compilation: JIT)：又叫实时编译、及时编译。是指一种在运行时期把字节码编译成原生机器码的技术，一句一句翻译源代码，但是会将翻译过的代码缓存起来以降低性能耗损。这项技术是被用来改善虚拟机的性能的。</p><p>JIT编译器是JRE的一部分。原本的Java程序都是要经过解释执行的，其执行速度肯定比可执行的二进制字节码程序慢。为了提高执行速度，引入了JIT。在运行时，JIT会把翻译过来的机器码保存起来，以备下次使用。而如果JIT对每条字节码都进行编译，则会负担过重，所以，JIT只会对经常执行的字节码进行编译，如循环，高频度使用的方法等。它会以整个方法为单位，一次性将整个方法的字节码编译为本地机器码，然后直接运行编译后的机器码。</p><h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2 异常"></a>2 异常</h3><p><strong>异常处理可以使得程序处理费预期场景，并且继续正常的处理</strong></p><p>在程序运行时，JVM如果检测出一个不可能执行的操作，就会出现<strong>运行时错误</strong>。Java中<strong>运行时错误会作为异常抛出</strong>。</p><p><strong>异常就是一种对象，表示阻止正常进行程序执行的错误或情况。如果异常没有被处理，那么程序会非正常终止。</strong></p><p><strong>异常是方法抛出的，方法的调用者可以捕获以及处理该异常，Java可以让一个方法抛出一个异常，该异常可以被调用者捕获和处理</strong></p><p><strong>如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。</strong></p><p><strong>异常分类</strong></p><p><strong>Throwable</strong> 是 Java 语言中所有错误或异常的超类。<strong>下一层分为 Error 和 Exception</strong></p><p><strong>Error（错误）</strong></p><p>Error 类是指Java运行时系统的内部错误和资源耗尽错误。<strong>是由JVM抛出的，应用程序不会抛出该类对象</strong>。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</p><p><strong>Exception</strong>(RuntimeException、CheckedException) </p><p><strong>RuntimeException（运行时异常）</strong></p><p> 如 : NullPointerException 、ClassCastException ; RuntimeException。是那些<strong>可能在 Java 虚拟机正常运行期间抛出的异常的超类</strong>。 描述的是程序设计的错误。</p><p><strong>CheckedException（必检异常）</strong></p><p><strong>Error和RuntimeException统称为免检异常。Exception下的其他的都是必检异常（和 RuntimeExceptio同级）</strong>如 I/O错误导致的 IOException、QLException。 </p><p>必检的意思是编译器会强制程序员检查，并通过try-catch块来进行处理，或者在方法头进行声明；而免检异常一般都是设计上的逻辑错误，Java不要求捕获声明免检异常</p><p><strong>CheckedException</strong>一般是外部错误，<strong>这种异常都发生在编译阶段</strong>，Java 编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一般包括几个方面:</p><ol><li><p>试图在文件尾部读取数据</p></li><li><p>试图打开一个错误格式的 URL</p></li><li><p>试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</p></li></ol><p><strong>Java的异常处理模型基于三种操作：声明一个异常、抛出一个异常、捕获一个异常</strong></p><p><strong>（1）声明异常（方法头）</strong></p><p>每个方法都要声明它可能抛出的必检异常的类型</p><p>在方法头中使用关键字 <code>thows</code>表明要抛出的异常种类（可以多个）</p><pre><code class="java">public void method() throws Exception1,Exception2，...</code></pre><p><strong>(2) 抛出异常（方法体）</strong></p><p>检测到异常的程序可以创建一个合适的异常类型的实例并抛出它，要在方法体中使用<code>thow</code>对可能有异常的地方进行判断和抛出</p><pre><code class="java">thow new IllegalArgumentException(&quot;错误信息的描述字符串&quot;);//隐式创建异常的实例</code></pre><p><strong>一般来说，异常类有两个构造方法，一个是无参的，一个是可带描述信息的，该参数称为异常消息，可以通过<code>getMessage()</code>来获取异常的异常消息</strong></p><p><strong>（3）捕获异常（方法调用时（可以是一个方法的定义中调用了另一个方法））</strong></p><p>使用<code>try-catch</code>块来捕获和处理异常，<code>finally</code>子句用来放置必然要执行的语句</p><pre><code class="java">try{   statements}catch(Exception1 ex1){   handdler for ex1}catch(Exception2 ex2){   handdler for ex2}  ···finally{  ···}</code></pre><p><strong>如果在执行try块的过程中没有出现异常，则跳过catch子句</strong></p><p>*<em>如果try块中的某条语句抛出一个异常，Java就会跳过剩余语句，然后开始查找处理这个异常的catch块，之后执行try-catch后的语句。处理这个异常的代码称作  异常处理器  *</em></p><p><strong>当某个调用的方法抛出一个异常，从当前的方法开始，沿着方法调用链，按照异常的反向传播方向去寻找这个异常的处理器（某个catch块），如果异常没有在当前方法被捕获，就被传给该方法的调用者，这个过程一直重复（不断向上寻找），直到异常被捕获或者被传给main方法（如果最终没有捕获就会终止程序）</strong></p><p><strong>任何情况情况下，finally中的代码都会执行（即便之前有return也会执行，finally是在本层的最后执行的）</strong></p><p>从一个通用父类可以派生出各种异常类，<strong>如果一个catch块可以捕获一个父类的异常对象，它就可以捕获那个父类的所有子类的异常对象</strong></p><p><strong>如果方法声明了一个必检异常（在方法头），那调用它的时候就必须加上<code>try-catch</code>块（在调用者这一层进行处理），或者在调用者的方法上声明同类异常（不在这一层处理，继续向上传导该异常）</strong></p><pre><code class="java">void p1(){//在调用者这一层进行处理  try{    p2();  }  catch (IOException ex){  ···  }}void p1() throws IOException{//不在这一层处理，继续向上传导该异常  p2();}</code></pre><p><strong>对于捕获多个异常使用同样代码处理，可以用JDK7的 多捕获特征  来写（使用 <code>|</code>来分隔多个异常）</strong></p><pre><code class="java">catch (Exception1 | Exception2 | ··· | Exceptionk ex){  ···}</code></pre><p><strong>从异常中获取信息</strong></p><p>使用Throwable类中的方法</p><p><code>getMessage()</code>获取描述该异常的信息</p><p><code>toString()</code>返回三个字符串连接    异常类名 ：<code>getMessage()</code></p><p><code>printStackTrace()</code> 打印<code>toString()</code>+<code>getStackTrace</code> </p><p><code>getStackTrace()</code> 返回该异常堆对象相关堆栈信息</p><p><strong>注意！使用异常需要  1 新建异常对象  2 从调用栈返回  3 沿方法调用链来传播异常以便找到异常处理器  这意味着花更长的时间和资源，所以要谨慎使用异常</strong></p><p><strong>重新抛出异常：如果在这一层处理不了这个异常，允许在catch中重新<code>thow</code>已经捕获异常，以便给本层后面的catch块或者上一层调用来处理</strong></p><p><strong>链式异常：同原始异常一起抛出一个新异常 比如<code>thow new Exception(&quot;新异常的信息&quot;, 上一层原始异常ex)</code></strong></p><p><strong>创建自定义异常：可以通过派生 Exception类来定义一个自定义异常类</strong></p><p><strong>文本I/O：File类 绝对/相对路径 I/O方法（Scanner PrintWriter 类）try-with-resources自动关闭资源</strong></p><p><strong>Scanner</strong>&amp;<strong>PrintWriter</strong>：</p><pre><code></code></pre><h3 id="3-Java反射"><a href="#3-Java反射" class="headerlink" title="3 Java反射"></a>3 Java反射</h3><p><strong>（1）反射概述</strong></p><p><strong>动态语言，是指程序在运行时可以改变其结构:新的函数可以引进，已有的函数可以被删除等结构上的变化。</strong>比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。<strong>从反射角度说 JAVA 属于半动态语言。</strong></p><p><strong>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法;并且对于任意一个对象，都能够调用它的任意一个方法</strong>;这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。</p><p>反射机制可以用来:</p><p><strong>1 在运行时分析类的能力 。</strong></p><p><strong>2 在运行时查看对象。例如，编写一个 toString 方法供所有类使用。</strong></p><p><strong>3 实现通用的数组操作代码。</strong></p><p><strong>4 利用 Method 对象， 这个对象很像c++中的函数指针。</strong></p><p><strong>（2）Java反射API</strong></p><p><strong>反射 API 用来生成 JVM 中的类、接口或则对象的信息。</strong></p><p><strong>1. Class 类</strong>:反射的核心类，可以获取类的属性，方法等信息。（Java.lang.Class）</p><p>（以下都是Java.lang.reflec 包中的类）</p><p><strong>2. Field 类 （域）</strong>:表示类的成员变量，可以用来获取和设置类之中的属性值。</p><p><strong>3. Method 类 （方法）</strong>: 表示类的方法，它可以用来获取类中的方法信息或者执行方法。</p><p><strong>4. Constructor 类 （构造器）</strong>: 表示类的构造方法。</p><p><strong>（3）反射使用步骤</strong></p><ol><li><p>获取想要操作的类的 Class 对象（<strong>3种方法</strong>），通过 Class 对象我们可以任意调用类的方法。</p></li><li><p>调用 Class 类中的方法（获取反射API对象），这是反射的使用阶段。</p></li><li><p>使用反射 API（<strong>Field Method Constructor的方法</strong>）来操作这些信息。</p></li></ol><p><strong>（4）Class类的使用</strong></p><p>在程序运行期间， Java 运行时系统始终<strong>为所有的对象</strong>维护一个被称为<strong>运行时的类型标识</strong>。 这个信息跟踪着每个对象所属的类。 虚拟机利用运行时类型信息选择相应的方法执行。<strong>保存这些信息的类被称为Class</strong>。 <strong>Object 类中的 getClass( ) 方法将会返回一个 Class 类型的实例</strong>。</p><p>一个 Class 对象将表示一个特定类的属性。</p><p><strong>（4.1）  获取Class对象</strong></p><pre><code class="java">E e = new E();String s = e.getClass().getName();//得到某个实例对应类的类名//获得Class类的3种方法Class cl = e.getClass();//通过调用类的实例的getClass()方法获取Class cl = E.class;//通过调用类的class属性来获取Class cl = Class.forName(&quot;类的全路径（包名+类名）&quot;);//（最安全|性能最好）这是个静态方法，可以根据类名来得到对应的类的Class类的实例。注意！无论何时使用这个方法，都应该提供一个异常处理器</code></pre><p>注意！一个 Class 对象实际上表示的是一个类型， 而这个类型未必一定是一种类。 例如， int 不是类， 但 int.class 是一个 Class 类型的对象。</p><p><strong>Class类实际上是一个泛型类</strong>。例如，Employee.class的类型是<code>Class&lt;Employee&gt;</code>。但其实在大多数实际问题 中， 可以忽略类型参数， 而使用原始的Class 类</p><p>注意！鉴于历史原 <strong>getName 方法在应用于数组类型的时候会返回一个很奇怪的名字</strong>: <strong>Double[]class.getName()返回“ [Ljava.lang.Double;’’<br> int[].class.getName()返回“ [I”，</strong></p><p><strong>虚拟机为每个类型管理一个 Class 对象。（所以对于同一个类来说，其Class实例时唯一的，所有引用都指向一个地方） 因此， 可以利用 = 运算符实现两个类对象比较 的操作。</strong></p><p>可以让启动变快的方法：首先， 显示一个启动画面; 然后，通过调用 Class.forName 手工地加载其他的类。（避免调用main方法加载所有的类花费大量时间）</p><p><strong>（4.2）通过Class类型创建对应类的实例的两种方法</strong></p><p>1.<strong>Class</strong> 对象的 <strong>newInstance()</strong></p><p>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象<strong>对应的类有默认的空构造器</strong>。（首先获得该类的Class对象，然后创建实例）</p><p>比如将 forName 与 newlnstance 配合起来使用， 可以根据存储在字符串中的类名创建一个对象</p><pre><code class="java">e.getClass().newlnstance();String s = &quot;java.util.Random&quot;;Object m = Class.forName(s).newlnstance();//注意使用时要类型转换</code></pre><p>2.调用 <strong>Constructor</strong> 对象的 <strong>newInstance()</strong> </p><p>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,<strong>通过这种方法可以选定构造方法创建实例</strong>。</p><pre><code class="java">//获取 Person 类的 Class 对象Class clazz = Class.forName(&quot;reflection.Person&quot;); //使用.newInstane 方法创建对象Person p = (Person) clazz.newInstance();//获取构造方法并创建对象（构造方法参数是对应类的Class对象）Constructor c = clazz.getDeclaredConstructor(String.class,String.class,int.class);//创建对象并设置属性Person p1 = (Person) c.newInstance(&quot;李四&quot;,&quot;男&quot;,20);</code></pre><p><strong>（4.3）调用Class的方法（得到对应的反射API实例）</strong></p><p>Class类中的<strong>getFields、getMethods和getConstructors方法</strong>将分别返回类提供的 public域、方法和构造器数组，其中包括超类的公有成员。</p><p> Class 类的 <strong>getDeclareFields、getDeclareMethods 和 getDeclaredConstructors 方法</strong>将分别返回类中声明的全部域、方法和构造器， 其中包括私有和受保护成员，但不包括超类的成员。</p><pre><code></code></pre><p><strong>（5）反射API的使用（Field Method Constructor）（用于检查类的结构）</strong></p><p>这三个类都有一个叫做 getName 的方法，用来返回项目的名称。</p><p>Method类有一 个 getType 方法，用来返回描述域所属类型的 Class 对象。 </p><p>Method 和 Constructor 类有能够报告参数类型的方法， Method 类还有一个可以报告返回类型的方法。 </p><p>这3个类还有一个叫 做 getModifiers 的方法，它将返回一个整型数值，用不同的位开关描述 public 和 static 这样 的修饰符使用状况。 </p><p>另外， 还可以利用 java.lang.reflect 包中的 Modifier 类的静态方法分析 getModifiers 返回的整型数值。 例如， 可以使用 Modifier 类中的 isPublic、 isPrivate 或 isFinal 判断方法或构造器是否是 public、 private 或 final。 我们需要做的全部工作就是调用 Modifier 类的相应方法， 并对返回的整型数值进行分析， 另外，还可以利用 Modifier.toString 方法将修饰符打印出来。</p><p><strong>（5.1）  运行时分析反射对象（查看修改数据域内容  Field类）</strong></p><p>在编写程序时， 如果知道想要査看的域名 和类型， 查看指定的域是一件很容易的事情。而利用反射机制可以查看在编译时还不清楚的对象域。</p><p><strong>（a）得到Field对象</strong></p><ol><li><p>使用getDeclaredFields方法来获得所有成员的一个Field对象数组，然后在进行查找</p></li><li><p>使用Class类的getField方法根据表示域名的字符串，返回一个 Field对象（<strong>要使用这个必须加上try-catch块</strong>）</p></li></ol><pre><code></code></pre><p><strong>（b）查看和修改Field对象</strong></p><p>查看和修改对象域的关键方法是 <strong>Field 类中的 get和set方法</strong>。 如果 f 是一个 Field 类型的对象(例如，通过 getDeclaredFields 得到的对象) obj 是某个包含 f 域的类的对象， <strong>f.get(obj) 将返回一个对象，其值为 obj 域的当前值</strong>。</p><p>当然，可以获得就可以设置 调用 <strong>f.set(obj value) 可以将 obj 对象的 f 域设置成新值</strong></p><pre><code class="java">Employee harry = new Employee(&quot;Harry Hacker&quot;, 35000, 10, 1, 1989);Class cl = harry.getClass();// 拿到了Employee的ClassField f = cl.getDeclaredField(&quot;name&quot;)://拿到了该类的指定成员的Filed对象Object v = f.get(harry);//使用该Field实例去用get方法获取某一个类的实例的指定成员的内容，并返回一个新的变量实例（注意是Object类型 要转换）// the value of the name field of the harry object, i .e., the String object &quot;Harry Hacker&quot;</code></pre><p>实际上，这段代码存在一个问题。由于 name 是一个私有域， 所以 get 方法将会抛出一个 IllegalAccessException。 只有利用 get 方法才能得到可访问域的值。 <strong>除非拥有访问权限， 否则 Java 安全机制只允许査看任意对象有哪些域， 而不允许读取它们的值。(必须要加上try-catch块)</strong></p><p>Field类使用还有很多内容，比如  对于基本类型获取，get方法可以自动打包，setAccessible 方法，编写通用 toString 方法**</p><p><strong>（5.2）  调用任意方法（Method类）</strong></p><p>在 C 和 C++ 中， 可以从函数指针执行任意函数。从表面上看， Java 没有提供方法指针， 即<strong>将一个方法的存储地址传给另外一个方法， 以便第二个方法能够随后调用它</strong>。事实上， Java 的设计者曾说过: 方法指针是很危险的， 并且常常会带来隐患。 他们认为 Java 提供的接口 (interface )是一种更好的解决方案。 然而，<strong>反射机制允许你调用任意方法</strong>。</p><p><strong>（a）得到Method对象</strong></p><ol><li><p>可以通过调用 getDeclareMethods 方法， 然后对返回的 Method 对象数组进行查找， 直到发现想要的方法为止。</p></li><li><p>也可以通过调用 Class 类中的 getMethod 方法得到想要的方法。因为有可能存在若干个相同名字的方法，所以还必须提供想要的方法的参数类型。<strong>(必须要加上try-catch块)</strong></p></li></ol><pre><code class="java">Method getMethod(String name, Class... parameterTypes)Method ml = Employee.class.getMethod(&quot;getName&quot;);Method m2 = Employee.class.getMethod(&quot;raiseSalary&quot;, double.class); </code></pre><p><strong>（b）调用Method对象中的方法</strong></p><p><strong>在 Method 类中有一个 invoke 方法， 它允许调用包装在当前 Method 对象中的方法。</strong></p><p>invoke方法的签名是 <code>Object invoke(Object obj, Object... args)</code></p><p>第一个参数是隐式参数， 其余的对象提供了显式参数</p><p>对于静态方法， 第一个参数可以被忽略， 即可以将它设置为 null</p><p>假设用 ml 代表 Employee 类的 getName 方法（是一个Method对象），下面这条语句显示了如何调用这个方法:</p><pre><code class="java">String n = (String) ml.invoke(harry);</code></pre><p> invoke 的参数和返回值<strong>必须是 Object 类型的</strong>。这就意味着必须进行多次的类型转换。 这样做将会使编译器错过检查代码的机会。 因此，等到测试阶段才会发现这些错误，找 到并改正它们将会更加困难。不仅如此，使用反射获得方法指针的代码要比仅仅直接调用方法明显慢一些。</p><p>有鉴于此， 建议仅在必要的时候才使用 Method 对象，而<strong>最好使用接口以及 Java SE 8 中 的 lambda 表达式</strong></p><p>建议 Java 开发者不要使用 Method 对象的回调功能。 使用接口进行回调会使得代码的执行速度更快， 更易于维护。<strong>（？不明白这是什么意思）</strong></p><h3 id="4-包-类路径-注释-注解"><a href="#4-包-类路径-注释-注解" class="headerlink" title="4 包  类路径  注释  注解"></a>4 包  类路径  注释  注解</h3><p>Java 允许使用包 （package）将类组织起来。 借助于包可以方便地组织自己的代码， 并将 自己的代码与别人提供的代码库分开管理。</p><p>标准的 Java 类库分布在多个包中， 包括 java.lang、java.util 和 java.net 等。 标准的 Java 包具有一个层次结构。 如同硬盘的目录嵌套一样， 也可以使用嵌套层次组织包。 所有标准的 Java 包都处于 java 和 javax 包层次中。</p><p>一个类可以使用所属包中的所有类， 以及其他包中的公有类(public class。) 我们可以 采用两种方式访问另一个包中的公有类。 第一种方式是在每个类名之前添加完整的包名（很麻烦）。</p><pre><code class="java">java.tiie.LocalDate today = java.tine.Local Date.now() ;</code></pre><p>更简单且更常用的方式是使用 import 语句。 import 语句是一种引用包含 在包中的类的简明描述。 一旦使用了 import 语句， 在使用类时， 就不必写出包的全名了。</p><p>可以使用 import 语句导人一个特定的类或者整个包。 import 语句应该位于源文件的顶部 ( 但位于 package 语句的后面 )。</p><pre><code class="java">import java.util.*;LocalDate today = LocalDate.now();</code></pre><p>在 C++中， 与 包 机 制 类 似 的 是 命 名 空 间(namespace)。 在 Java 中， package 与 import 语句类似于 C++中的 namespace 和 using 指令。</p><p><strong>静态导入</strong></p><p>import 语句不仅可以导入类， 还增加了导人静态方法和静态域的功能。（调用静态域和方法时更方便）</p><pre><code class="java">import static java.lang.System.*;out.println(&quot;Goodbye, World!&quot;); // i.e., Systeme., System.exit exit(9); //i.</code></pre><p>要想将一个类放人包中， 就必须将包的名字放在源文件的开头， 包中定义类的代码之前。</p><pre><code class="java">package com.horstiann.corejava;public class Employee{}</code></pre><p>如果没有在源文件中放置 package 语句， 这个源文件中的类就被放置在一个默认包 ( defaulf package ) 中。 默认包是一个没有名字的包。 </p><p><strong>类路径</strong></p><p>类存储在文件系统的子目录中。 类的路径必须与包名匹配。</p><p>另外， 类文件也可以存储在 JAR(Java 归档 )文件中。 在一个 JAR 文件中， 可以包含 多个压缩形式的类文件和子目录， 这样既可以节省又可以改善性能。 在程序中用到第三方 ( third-party ) 的库文件时， 通常会给出一个或多个需要包含的 JAR 文件。JDK 也提供了许多 的 JAR 文件</p><p>JAR 文件使用 ZIP 格式组织文件和子目录。可以使用所有 ZIP 实用程序查看内部 的 rt.jar 以及其他的 JAR 文件。</p><p><strong>文档注释</strong></p><p>JDK 包含一个很有用的工具， 叫做 javadoc, 它可以由源文件生成一个 HTML 文档。 </p><p>如果在源代码中添加以专用的定界符 /** 开始的注释， 那么可以很容易地生成一个看上 去具有专业水准的文档。这是一种很好的方式， 因为这种方式可以将代码与注释保存在一个 地方。如果将文档存人一个独立的文件中， 就有可能会随着时间的推移， 出现代码和注释不 一致的问题。 然而， 由于文档注释与源代码在同一个文件中， 在修改源代码的同时， 重新运 行 javadoc 就可以轻而易举地保持两者的一致性。</p><p>@author @param 等等</p><p><strong>Java注解</strong></p><p>Annotation(注解)是 Java 提供的一种对元程序中元素关联信息和元数据(metadata)（关于数据的数据）的途径和方法。Annatation(注解)是一个接口，程序可以通过<strong>反射</strong>来获取指定程序中元素的 Annotation对象，然后<strong>通过该 Annotation 对象来获取注解中的元数据信息</strong>。</p><p>元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。</p><p><strong>4种元注解（负责注解其他注解）</strong></p><p><strong>@Target</strong> 修饰的对象范围</p><p>@Target 说明了 Annotation 所修饰的对象范围: Annotation 可被用于 packages、types(类、</p><p>接口、枚举、Annotation 类型)、类型成员(方法、构造方法、成员变量、枚举值)、方法参数</p><p>和本地变量(如循环变量、catch 参数)。在 Annotation 类型的声明中使用了 target 可更加明晰</p><p>其修饰的目标</p><p><strong>@Retention</strong> 定义 被保留的时间长短</p><p>Retention 定义了该 Annotation 被保留的时间长短:表示需要在什么级别保存注解信息，用于描</p><p>述注解的生命周期(即:被描述的注解在什么范围内有效)，取值(RetentionPoicy)由:</p><p>SOURCE:在源文件中有效(即源文件保留)</p><p>CLASS:在 class 文件中有效(即 class 保留)</p><p>RUNTIME:在运行时有效(即运行时保留)</p><p><strong>@Documented</strong> 􏰁描述<strong>javadoc</strong></p><p>@ Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。</p><p><strong>@Inherited</strong> 阐述了某个被标注的类型是被继承的</p><p>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该class 的子类。</p><p><strong>3种标准注解</strong></p><p><strong>@override</strong> 函数重写</p><p><strong>@Deprecated</strong> 对不应该再使用的方法做注释</p><p><strong>@SuppressWarnings</strong> 关闭特定警告信息（有参数）</p><p><strong>注解处理器</strong></p><p>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建和使用注解处理器（利用元注解）</p><pre><code class="java">/1:*** 定义注解*/   @Target(ElementType.FIELD)   @Retention(RetentionPolicy.RUNTIME)  @Documentedpublic @interface FruitProvider {/**供应商编号*/public int id() default -1; /*** 供应商名称*/public String name() default &quot;&quot;;/** * 供应商地址*/public String address() default &quot;&quot;;}//2:注解使用public class Apple {@FruitProvider(id = 1, name = &quot;陕西红富士集团&quot;, address = &quot;陕西省西安市延安路&quot;)private String appleProvider;public void setAppleProvider(String appleProvider) {this.appleProvider = appleProvider; }public String getAppleProvider() { return appleProvider;}}/3:*********** 注解处理器 ***************/public class FruitInfoUtil {public static void getFruitInfo(Class&lt;?&gt; clazz) {String strFruitProvicer = &quot;供应商信息:&quot;;Field[] fields = clazz.getDeclaredFields();//通过反射获取处理注解for (Field field : fields) {if (field.isAnnotationPresent(FruitProvider.class)) {FruitProvider fruitProvider = (FruitProvider) field.getAnnotation(FruitProvider.class); //注解信息的处理地方strFruitProvicer = &quot; 供应商编号:&quot; + fruitProvider.id() + &quot; 供应商名称:&quot;+ fruitProvider.name() + &quot; 供应商地址:&quot;+ fruitProvider.address();System.out.println(strFruitProvicer); }} } } public class FruitRun {public static void main(String[] args) {FruitInfoUtil.getFruitInfo(Apple.class); /***********输出结果***************/// 供应商编号:1 供应商名称:陕西红富士集团 供应商地址:陕西省西安市延 }}</code></pre><h3 id="5-日志-断言-调试"><a href="#5-日志-断言-调试" class="headerlink" title="5 日志 断言 调试"></a>5 日志 断言 调试</h3><h3 id="6-Java序列化（创建可复用的Java对象）"><a href="#6-Java序列化（创建可复用的Java对象）" class="headerlink" title="6  Java序列化（创建可复用的Java对象）"></a>6  Java序列化（创建可复用的Java对象）</h3><p><strong>Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，这些对象才可能存在</strong>，即，这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中，<strong>就可能要求在 JVM 停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象</strong>。Java 对象序列化就能够帮助我们实现该功能。</p><p>使用 Java 对象序列化，<strong>在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象</strong>。必须注意地是，<strong>对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量</strong>。</p><p>除了在<strong>持久化对象</strong>时会用到对象序列化之外，当使用 <strong>RMI(远程方法调用)</strong>，或在<strong>网络中传递对象</strong>时，都会用到对象序列化。<strong>Java 序列化 API 为处理对象序列化提供了一个标准机制</strong>，该 API 简单易用。</p><p><strong>Serializable</strong> 实现序列化</p><p>在 Java 中，只要一个类实现了 java.io.Serializable 接口，那么它就可以被序列化。</p><p>通过 ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化。</p><p>在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略。</p><p><strong>序列化ID</strong></p><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致(就是 private static final long serialVersionUID)</p><p><strong>Transient</strong> 关键字阻止该变量被序列化到文件中</p><p>在变量声明前加上Transient 关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p><p>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面向对象</title>
    <link href="/2021/02/28/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/02/28/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>###Java面向对象部分笔记</p><p>（对象和类  抽象与封装  继承与多态）</p><p><strong>面向对象三大支柱是： 封装  继承  多态</strong></p><h3 id="0-面向对象5大原则"><a href="#0-面向对象5大原则" class="headerlink" title="0  面向对象5大原则"></a>0  面向对象5大原则</h3><p><strong>单一职责原则（Single-Resposibility Principle）</strong>：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。<br> <strong>开放封闭原则（Open-Closed principle）：</strong>软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。<br> <strong>Liskov替换原则（Liskov-Substituion Principle）</strong>：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。<br> <strong>依赖倒置原则（Dependecy-Inversion Principle）</strong>：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。<br> <strong>接口隔离原则（Interface-Segregation Principle）</strong>：使用多个小的专门的接口，而不要使用一个大的总接口</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="1-对象和类"><a href="#1-对象和类" class="headerlink" title="1 对象和类"></a>1 对象和类</h3><h4 id="（1）对象和类的基本概念"><a href="#（1）对象和类的基本概念" class="headerlink" title="（1）对象和类的基本概念"></a>（1）对象和类的基本概念</h4><p>类是对象的模板，一个类的声明中定义了对象应该有的变量、方法以及构造实例的构造方法。通过声明变量和构造方法可以创建类的实例（类名要大写）</p><p>类是一种引用类型，区别于8种基本数据类型，所有变量存储的都是都是对类的一个实例的地址客空间的地址。（注意  变量的声明  对象的创建  以及  对象引用的赋值  这三个过程的区别）</p><p>通过   “.”  来访问对象的变量和方法</p><p>实例变量  实例方法（与创建的对象绑定）</p><p>*<em>静态变量（所有类的实例共享该变量，在公共内存地址，无需创建对象就可以访问）  *</em></p><p><strong>静态方法（可以通过类直接调用，无需创建对象）</strong></p><p>（也可以通过引用变量来调用）（要加修饰符 static）</p><p><strong>常量 ：类中的常量是被所有对象共享的，应当被声明为final static</strong></p><p>（实例方法可以调用其对象所有资源，而静态方法只能调用类的静态资源）</p><p>匿名对象（直接new了用，不给变量指向它）</p><p>声明一个引用对象而不赋值，Java不会给其赋默认值null</p><p>如果一个对象的数据域中的引用类型的变量没有引用对象，Java会给其赋默认值null（基本类型会赋 0 /u000 false），但Java不会给方法中的局部变量（包括基本类型）赋默认值</p><p>每个变量都代表一个内存地址，基本类型变量指向的内存地址存的是值，而引用类型变量存的是指向是这个对象实际内存地址</p><p>不被任何变量指向的对象会被JVM回收掉（垃圾回收）</p><p>含有main方法的是会被执行的类，成为主类（main函数是程序程序的入口）其他类都不可运行</p><p>一个文件可以有多个类，但只能有一个public类，只有这个public类中才会有main函数，公共类必须和文件同名。（但注意编译的时候每个类都会编译成一个 .class文件）</p><h4 id="（2）修饰符"><a href="#（2）修饰符" class="headerlink" title="（2）修饰符"></a>（2）修饰符</h4><p><strong>（2.1）可访问性修饰符（四个等级）</strong></p><p>（用于确定一个类及其成员的可见性）</p><p>package用来组织类，表明类的归属</p><p>不添加修饰符被视为可以被同一个package的类访问</p><p>public表示可以被任何类访问</p><p>private表示只能在它自己的类中被访问（只能用于类的成员上）</p><p>如果一个类不是public的，则它只能被同一个package的类访问</p><p>构造方法可以是public也可以是private（仅当时静态类不想被创建实例时使用，一般都是公共的）</p><table><thead><tr><th></th><th>同一个类中</th><th>同一个package中</th><th>在子类中</th><th>在不同package中</th></tr></thead><tbody><tr><td>public</td><td>O</td><td>O</td><td>O</td><td>O</td></tr><tr><td>protected</td><td>O</td><td>O</td><td>O</td><td>X</td></tr><tr><td>(default)</td><td>O</td><td>O</td><td>X</td><td>X</td></tr><tr><td>private</td><td>O</td><td>X</td><td>X</td><td>X</td></tr></tbody></table><p>protected允许子类可以访问父类的变量，而默认（default）和private不可以</p><p><strong>private和protected只可以用于类的变量和方法，而public和默认（default）可以用于类或者类的变量和方法</strong></p><p><strong>注意方法的修饰的类型，要在子类中调用或者重写的方法一定要在父类声明时用public或者protected（子类可能不在同一个package内！）</strong></p><h5 id="（2-2）防止扩展与重写（final修饰符）"><a href="#（2-2）防止扩展与重写（final修饰符）" class="headerlink" title="（2.2）防止扩展与重写（final修饰符）"></a>（2.2）防止扩展与重写（final修饰符）</h5><p><strong>final修饰的类不可以被继承，final修饰的方法不可以被子类重写，final还可以修饰局部变量，这时这个局部变量变量就是常量</strong></p><h4 id="（3）-数据域封装"><a href="#（3）-数据域封装" class="headerlink" title="（3） 数据域封装"></a>（3） 数据域封装</h4><p>将类的所有变量都设为私有变量，然后通过公共的getter和setter方法进行访问</p><h4 id="（4）-调用类的方法的底层细节"><a href="#（4）-调用类的方法的底层细节" class="headerlink" title="（4） 调用类的方法的底层细节"></a>（4） 调用类的方法的底层细节</h4><p>基本类型的变量存放在栈中，引用类型的对象被创建后会存放在内存的堆中。当方法被调用时其局部变量被放在栈中。栈中引用类型的变量存的是指向栈中对象的引用。</p><p>（待补充）</p><h4 id="（5）-不可改变类和对象"><a href="#（5）-不可改变类和对象" class="headerlink" title="（5） 不可改变类和对象"></a>（5） 不可改变类和对象</h4><p>通过不可改变类创建的对象就是不可改变对象，比如String</p><p>如果一个类是不可改变类，那么其  1数据域必须是私有的，2不能提供setter方法，3没有一个返回指向可变数据域的引用的getter</p><h4 id="（6）-局部变量优先于类变量（类变量被隐藏）"><a href="#（6）-局部变量优先于类变量（类变量被隐藏）" class="headerlink" title="（6） 局部变量优先于类变量（类变量被隐藏）"></a>（6） 局部变量优先于类变量（类变量被隐藏）</h4><h4 id="（7）-this引用"><a href="#（7）-this引用" class="headerlink" title="（7） this引用"></a>（7） this引用</h4><p>this指向调用对象自身，也可以在构造方法内部用于调用同一个类的其他构造方法（this(其他构造方法的参数列表)  要求这个在构造方法中出现在任何其他可执行语句之前）</p><p>当类变量被隐藏时，必须用this来引用</p><h4 id="（8）-类的抽象和封装"><a href="#（8）-类的抽象和封装" class="headerlink" title="（8） 类的抽象和封装"></a>（8） 类的抽象和封装</h4><p>抽象是指将类的使用和实现分离</p><p>封装是指实现的细节被封装并且对用户隐藏</p><p>类被称作  抽象数据类型ADT</p><h4 id="（9）-类的关系"><a href="#（9）-类的关系" class="headerlink" title="（9） 类的关系"></a>（9） 类的关系</h4><p>关联  聚集（has-a  所有者称为聚集对象）  组合（一个对象只归属于一个聚集对象） 继承</p><h4 id="（10）-基本类型和包装类型"><a href="#（10）-基本类型和包装类型" class="headerlink" title="（10） 基本类型和包装类型"></a>（10） 基本类型和包装类型</h4><p>既可以用数值也可用字符串来构造包装类  new Integer(“7”)</p><p>每个包装类都包含 类似 intValue()  的方法进行拆箱</p><p>包装类没有无参构造方法，所有包装类的实例都是不可变的</p><p>每一个数值包装类都是常量MAX_VALUE和MIN_VALUE，代表基本数据类型的最大最小值（对于·浮点代表最小正值）</p><p>都有compareTo方法来进行比较（也可以直接用关系操作符比较）</p><p>静态方法  <code>Integer.valueOf(String s)</code>  创建一个新的包装类的对象（将String转化为包装类）</p><p>静态方法   <code>Integer.parseInt(String s , int  radix)</code>  将String转化为一个十进制基本数据类型（后一个参数是说明这个String中的数是几进制，可以没有）</p><p>装箱  开箱  Java允许基本类型和包装类的自动转换，编译器会根据需要自动装箱开箱</p><h4 id="（11）-BigInteger-BigDecimal-（去看一下源码是怎么实现的）"><a href="#（11）-BigInteger-BigDecimal-（去看一下源码是怎么实现的）" class="headerlink" title="（11） BigInteger  BigDecimal  （去看一下源码是怎么实现的）"></a>（11） BigInteger  BigDecimal  （去看一下源码是怎么实现的）</h4><p>new  BigInteger(String)  来创建</p><p>BigInteger的实例可以是任意大小整数  BigDecimal 没有精读限制，但可以用重载的方法限制来避免除不尽的异常</p><p>使用 add  subtract multiple  divide  remainder  来完成算术运算 compareTo来比较</p><p>都是不可改变的</p><h4 id="（12）-String"><a href="#（12）-String" class="headerlink" title="（12） String"></a>（12） String</h4><p>Java将字符串直接量看做String对象</p><p>也可以用char[] 来创造一个字符串</p><p> 字符串转换成字符数组 toCharArray()</p><p>使用format方法格式化字符串</p><p><strong>关于new和直接赋值的不同，以及在==下情况的不同</strong></p><p><strong>直接赋值而不是使用new关键字给字符串初始化，在编译时就将String对象放进字符串常量池中；使用new关键字初始化字符串时，是在堆栈区存放变量名和内容；</strong>字符串的拼接操作在程序运行时，才在堆中创建对象。一般，可以认为使用==”比较的是引用，equals比较的是内容。</p><p>String str1 = “java”;      //直接赋值而不是使用new关键字给字符串初始化，在编译时就将String对象放进字符串常量池中<br>String str2 = new String(“java”);//在堆中创建新对象</p><p>String str3 = “java”;   //直接赋值而不是使用new关键字给字符串初始化，在编译时就将String对象放进字符串常量池中</p><p>String s = str1+str2;      //字符串的拼接操作在程序运行时，才在堆中创建对象，相当于new<br>System.out.print(s==”javajava”  s1==s3  s1==s2);</p><p>答案是 false  true  false</p><h4 id="（13）-正则表达式-使用-字符串-matches-“正则表达式”-来匹配符合正则表达式的字符串（返回true-false）（学习一下正则表达式的规则）"><a href="#（13）-正则表达式-使用-字符串-matches-“正则表达式”-来匹配符合正则表达式的字符串（返回true-false）（学习一下正则表达式的规则）" class="headerlink" title="（13） 正则表达式  使用  字符串.matches(“正则表达式”)  来匹配符合正则表达式的字符串（返回true false）（学习一下正则表达式的规则）"></a>（13） 正则表达式  使用  字符串.matches(“正则表达式”)  来匹配符合正则表达式的字符串（返回true false）（学习一下正则表达式的规则）</h4><h4 id="（14）-StringBuilder-StringBuffer（字符串构造器）（去看一下JDK源码）"><a href="#（14）-StringBuilder-StringBuffer（字符串构造器）（去看一下JDK源码）" class="headerlink" title="（14）  StringBuilder StringBuffer（字符串构造器）（去看一下JDK源码）"></a>（14）  StringBuilder StringBuffer（字符串构造器）（去看一下JDK源码）</h4><p>StringBuilder 是同步的，只有一个任务被允许执行方法；StringBuffer多任务并发访问的</p><p>除了这一点他们的方法都是一样的（单任务Builder更有效）</p><p>默认构造容量是16，可以指定容量，指定字符串（3个构造方法）</p><p>（如果有用到就去看看其方法如何使用）</p><h3 id="2-继承（is-a）（class-Apple-extends-Fruit-）"><a href="#2-继承（is-a）（class-Apple-extends-Fruit-）" class="headerlink" title="2 继承（is-a）（class  Apple extends  Fruit  ）"></a>2 继承（is-a）（class  Apple extends  Fruit  ）</h3><p>Java不允许多重继承，但是可以通过接口来实现</p><p>定义一个通用的类（父类），之后扩充该类为一个更加特定的类（子类）</p><p>子类拥有父类的所有属性和方法（父类的构造方法不会被继承），共有属性和方法可以直接使用，但父类的私有属性和方法子类是无法直接使用的，私有方法是用不了的，而私有属性则必须父类提供了get或set才可以访问或修改</p><p>分析内存后，会发现，当一个子类被实例化的时候，默认会先调用父类的构造方法对父类进行初始化，即在内存中创建一个父类对象，然后再父类对象的外部放上子类独有的属性，两者合起来成为一个子类的对象</p><p>super关键字  指代父类 可以用于调用父类中的普通方法和构造方法</p><p>在子类的构造方法中显示的super必须在第一条语句，不可以直接写父类名字（<strong>注意即使你不显式的写super，编译器也会自动的将super()作为第一条语句，先调用父类的构造方法</strong>）</p><p><strong>构造方法链：  当构造一个类的实例时，会调用沿着继承链的所有父类的构造方法（从祖先开始，一层一层调用创建）（所以设计父类的时候最好提供一个无参构造方法，防止子类的构造方法调用时出现错误）</strong></p><p><strong>方法重写（覆盖）（overriding）：当父类中的一些方法对子类不适用时，就需要提供一个新的方法来 override 父类中的这个方法。（注意  私有方法和静态方法不可被重写，静态方法一旦被重写，父类中的就会被隐藏，要通过 父类名.方法名 调用）</strong></p><p>*<em>遵循  “两同两小一大”原则   *</em></p><p><strong>两同：方法名、参数列表相同。</strong></p><p><strong>两小：子类的返回类型（指的是继承关系的大小）、抛出的异常小于等于父类</strong></p><p><strong>一大：访问修饰符大于等于父类的访问修饰符（四个等级）</strong></p><p>当被重写时，就可以使用super调用父类的原方法</p><p>在编写代码时，建议在覆盖一个方法时加上 @override，除了标识的作用，它还会帮助你检查你覆盖的这个方法是否在父类中真的存在。</p><p><strong>方法重载（overloading）：多个方法具有相同的名字且拥有不同的参数列表时，就会出现重载，由编译器决定调用哪个方法，这个过程被称为 overloading resolution（重载解析）</strong></p><p>方法重载既可以在统一各类中发生，也可以在子类中重载由父类继承而来的方法</p><p><strong>Java中所有的类都继承自Object类（Java.lang.Object  lang里的东西都不用import （编译器会自己带上））如果一个类没有指定父类，那其父类就默认是Object（所以除了Object所有类都有有父类，都存在继承）</strong></p><p>Object的 toString()方法会返回一个描述该对象的字符串，<strong>类名+@+该对象16进制的内存地址</strong>，我们可以对它进行重写</p><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3  多态"></a>3  多态</h3><p><strong>多态意味着父类的变量可以指向子类对象</strong></p><p><strong>面向对象三大支柱是： 封装  继承  多态</strong></p><p>子类型  父类型d</p><p>每个子类的实例都是父类的实例，但是父类的实例不是子类的实例</p><p><strong>所以总可以将子类的实例传给父类的变量，但反过来不行</strong></p><p><strong>（多态意味着父类型的变量可以引用子类型的对象）</strong></p><p><strong>声明类型&amp;实际类型：对象声明时的类型是声明类型，而实际类型是其声明类型或者声明类型的子类，要看具体指向什么。（声明类型决定了编译时匹配哪个方法）</strong></p><p><strong>（运行时）动态绑定：由对象的实际类型决定调用哪个方法（是父类的还是子类重写的）（方法可以沿着继承链的多个类中实现，JVM决定运行时调用哪个方法）（先看实际类型，没有的话会从那个子类往祖先找实现的方法？）</strong></p><p><strong>对象转换和instanceof运算符</strong></p><p><strong>对象转换：对象的引用可以类型转换为对另外一种对象的引用</strong></p><p><strong>隐式转换：声明是父类，而赋值是子类的引用（注意此时的类型是父类，不能直接赋给子类的变量，需要显示转换成子类） Object o = new Student();</strong></p><p>*<em>显式转换：<code>Student b = (Student) o;</code> *</em></p><p><strong>向上转换：总是可以将子类变量转换为父类变量，子类的实例永远是它父类的实例，可以隐式转换（直接赋值就行）</strong></p><p><strong>向下转换：将父类实例转换为子类变量，必须要显式转换（转换的前提是这个父类的实例本来就是子类的实例，只是声明是父类）</strong></p><p>*<em>instanceof操作符(是关键字)：用于判断一个对象obj是否为一个类的Class 的对象，或者是其直接或间接子类，或者是其接口的实现类（是则返回true）  <code>if(obj instanceof Class)</code> *</em></p><p><strong>Java关键字中每个字母都是小写的</strong></p><p><strong>对象转换的好处：将变量定义为父类型的好处是可以接受任何子类型的值，在需要使用的是时候再具体转换，方便管理使用</strong></p><p><strong>注意！成员访问符 .  的优先级高于类型转换，要加括号！<code>((Student)  o  ).toString()</code></strong></p><p><strong>Object类的equals方法：A.equals(B)  判断两个对象是否一样 ==实现（指向同一对象），在String和Date都被重写，用于比较内容（而不是直接==）</strong></p><h3 id="4-抽象类"><a href="#4-抽象类" class="headerlink" title="4 抽象类"></a>4 抽象类</h3><p><strong>抽象类不可以创建对象，可以包含抽象方法（可以有普通成员），这些方法将在子类中实现。</strong></p><p><strong>抽象类和抽象方法用abstract来修饰，抽象方法只有方法头的定义，不能有方法体（ abstract  void  time(参数);（注意这些在子类都不能改））</strong></p><p><strong>抽象方法不能包含在非抽象类中；抽象类可以有构造方法不能new但是可以给子类调用（所以要声明为protected）；子类可以覆盖父类的方法并定义为abstract（在父类方法于子类中无效时），但子类必须声明为为abstract；父类具体子类也可以抽象；抽象类可以作为声明类型（虽然不能new）；子类可以不完全实现抽象方法（可以不用重复写在子类中），但这样子类也必须是抽象类</strong></p><h3 id="5-接口"><a href="#5-接口" class="headerlink" title="5  接口"></a>5  接口</h3><p><strong>父类型了相关子类中的共同行为，接口可以用于定义类的共同行为（包括非相关的类）；接口之只包含常量和抽象方法</strong></p><p><strong>接口目的在于知名相关或者或者不相关类的多个对象的共同行为</strong></p><p><strong>Java中接口被看做特殊的类，每个接口和类一样被便以为独立的字节码文件</strong></p><p><strong>（1）接口的声明和使用</strong></p><p><strong>声明一个接口：修饰符  interface  接口名{  常量声明   抽象方法  }</strong></p><p><strong>利用extends  接口可以继承其它接口（可以继承多个（相当于它的父类））（称为子接口）</strong></p><p><strong>类和接口的关系称为  接口继承  类使用implements来继承接口（和类继承一样）</strong></p><p><strong>和抽象类类似，接口不能new，但可以作为数据类型。一个接口的变量可以引用任何实现该接口的类的实例，一旦一个类实现了该接口，这个接口（以及这个接口继承的所有接口 都）相当于它的父类。（显式、隐式转换同样适用）</strong></p><p><strong>（2）接口的变量和方法（变量是公共静态的，方法是公共抽象的）</strong></p><p><strong>注意！接口中所有数据域都是 public static final  所有方法都是  public  abstract  所以Java允许在写接口时忽略这些修饰符（所以继承自接口的方法必须是公共  抽象  实例方法（不允许静态方法））</strong></p><p><strong>注意！一个类必须实现它继承接口的所有抽象方法！</strong></p><p><strong>（3）接口的静态方法</strong></p><p>对于静态方法，以往通常的做法都是将静态方法放在伴随类中。在标准库中，你会看到成对出现的接口和实用工具类， 如 Collection/Collections 或 Path/Paths。</p><p><strong>而在 Java SE 8 中，允许在接口中增加静态方法。（所以可以直接写静态方法，伴随类已经过时了）</strong></p><p><strong>（4）接口的默认方法</strong></p><p>对于接口的方法可以提供一个默认实现，用<code>default</code>标记。大部分时间没什么用（因为一单继承就要被覆盖）</p><p><strong>默认方法的一个重要用法是“‘ 接口演化” （interface evolution），因为为接口增加一个非默认方法不能保证“源代码兼容”，所以对于老接口进行新增时往往用默认方法</strong></p><p><strong>比如说我们之前类A实现了接口B，现在我们在接口B又新添加了一个方法C，这时候如果C不是default的，那就会出现编译错误（因为A没有实现C）</strong></p><p>不过， 假设不重新编译这个类， 而只是使用原先的一个包含这个类的 JAR 文件。这个类 仍能正常加载， 尽管没有这个新方法。 程序仍然可以正常构造 Bag 实例，不会有意外发生。(为接口增加方法可以保证“ 二进制兼容”)。不过，如果程序在一个Bag实例上调用stream 方法， 就会出现一个 AbstractMethodError。</p><p>将方法实现为一个默认方法就可以解决这两个问题。 Bag 类又能正常编译了。 另外如果 没有重新编译而直接加载这个类， 并在一个 Bag 实例上调用 stream 方法， 将调用 Collection. stream 方法。</p><p><strong>默认方法冲突（这里有很多情况，具体等遇到再仔细看吧）</strong></p><p>如果先在一个接口中将一个方法定义为默认方法， 然后又在超类或另一个接口中定义了 同样的方法就会产生冲突，Java用以下规则解决这个问题：</p><p>1 ) 超类优先。 如果超类提供了一个具体方法， 同名而且有相同参数类型的默认方法会被忽略。</p><p>2 ) 接口冲突。 如果一个超接口提供了一个默认方法， 另一个接口提供了一个同名而且 参数类型(不论是否是默认参数)相同的方法， 必须覆盖这个方法来解决冲突。</p><p><strong>（5）一些实用的接口</strong></p><ol><li><strong>Comparable接口：定义了compareTo，用于比较</strong></li></ol><p><code>public interface Comarable&lt;E&gt; {</code></p><p>​    <code>public int compareTo(E o);</code></p><p><code>}</code></p><p><strong>如果自定义的类也要实现对象间比较，要继承并实现这个接口（自定义比较逻辑）</strong></p><p>这是一个泛型接口，所有包装类和Date都实现了这个接口，所以他们之间是可以比较大小的</p><ol start="2"><li><strong>Cloneable接口：定义了clone，用于创建一个对象拷贝</strong></li></ol><p><code>public interface Cloneable{ }</code></p><p><strong>一个空的接口称为标记接口，及不含常量也不含方法，用来表示一个类拥有某些特定属性</strong></p><p>实现Cloneable接口的类标记为可克隆的，并且它的对象可以使用在Object类中定义的clone()方法克隆</p><p><strong>Object类中对clone()方法头：</strong></p><p><code>protected native Object clone() throws CloneNotSupportedException</code></p><p><strong>native</strong>表示不是用Java写的，但它是JAM针对自身平台来实现的</p><h3 id="6-Java-复制"><a href="#6-Java-复制" class="headerlink" title="6  Java 复制"></a>6  Java 复制</h3><p>Java中有三种复制方式：直接赋值复制、浅复制、深复制</p><p><strong>1 直接赋值复制</strong></p><p>基本类型复制的是值，对象复制的是引用</p><p><strong>后两种方式都是基于Object中的clone()方法来复制的，它的原理是创建一个新的Object对象，然后把所有成员都按照直接赋值复制方式复制一份</strong></p><p><strong>2 浅复制</strong></p><p><strong>重写Object中的clone()方法，克隆一个对象，但是数据域中的抽象成员复制的是引用</strong></p><p>要在目标类上implements  Cloneable接口，然后重写这个方法（改成public）</p><p><code>public Object clone() throws CloneNotSupportedException{</code></p><p><code>return super.clone();</code></p><p><code>}</code></p><p>在使用clone()方法时注意要显式转换一下（因为声明类型是Object的）</p><p><code>House house2 = (House)house1.clone()</code></p><p>这里要注意，Object中的clone()方法是将原始对象的每个数据域复制给目标，基本类型直接赋值，而<strong>抽象类型复制的是引用</strong></p><p>另一种代码：</p><pre><code class="java">class Resume implements Cloneable{public Object clone() { try { return (Resume)super.clone(); } catch (Exception e) {e.printStackTrace(); return null;  }}  }</code></pre><p><strong>3 深复制（两种实现方式）</strong></p><p>深复制为包括数据域的对象在内的全部克隆（其实就是把对象成员再用clone给克隆了再赋值）（克隆的范围扩大到类的成员）</p><p><strong>但这里有一个问题，如果成员的成员也是对象，那样第三层将复制的还是引用，有没有办法直接解决这个问题？</strong></p><p><strong>1  利用Object中的clone()方法实现代码：</strong></p><pre><code class="java">class Student implements Cloneable { String name;int age;Professor p;Student(String name, int age, Professor p) { this.name = name;this.age = age;this.p = p;}public Object clone() {Student o = null;   try {o = (Student) super.clone();} catch (CloneNotSupportedException e) {System.out.println(e.toString()); }o.p = (Professor) p.clone();return o; }}</code></pre><p><strong>2  利用序列化实现深复制：</strong></p><p>在 Java 语言里深复制一个对象，常常可以先使对象实现 Serializable 接口，然后把对<br>象(实际上只是对象的一个拷贝)写到一个流里，再从流里读出来，便可以重建对象。</p><h3 id="7-泛型"><a href="#7-泛型" class="headerlink" title="7  泛型"></a>7  泛型</h3><p><strong>泛型可以使我们在编译时而不是运行时检测出错误</strong></p><p>泛型可以将<strong>类型参数化</strong>，使我们可以定义带泛型类型的类或方法，随后编译器会用具体的类型来替换它。</p><p>泛型类型和或方法允许用户指定和这些类和方法一起工作的对象类型，如果试图使用一个不相容的对象，编译器就会检测出这个错误。</p><p>从JDK1.5开始，Java允许定义泛型  类、接口、方法  </p><p><code>&lt;T&gt;或&lt;E&gt;</code>表示形式泛型类型，随后可以用一个实际具体类型来替换他。替换的过程称为  泛型实例化</p><p>泛型类型只能是引用类型</p><p><strong>注意！在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</strong></p><p><strong>受限的泛型类型（确定泛型的上下边界）：将泛型定义为<code>&lt;E extends 类A&gt;</code>表明泛型E必须是A的子类型（泛型的上下边界添加，必须与泛型的声明在一起）</strong></p><p><strong>泛型类和接口</strong></p><p>可以定义泛型接口和泛型类（虽然将元素类型设置为Object也可以容纳所有对象，但不能编译时检测出错误）</p><p>带泛型类型的类的构造方法还是和没有的时候一样</p><p>不能对确切的泛型类型使用instanceof操作</p><p>带泛型的类或者接口，其类和接口名就是带<code>&lt;E&gt;</code>的，表示了它里面使用了泛型E。对于类来说，在new这个类的实例的时候或者声明这个类的实例，再表明实际类型。对于接口来说，<strong>在类继承此接口时，要么在类继承时标明实际类型，要么类也一起加上泛型</strong></p><pre><code class="java">public class Stack&lt;E1,E2,E3&gt; {}Stack&lt;String,Integer,Double&gt; stack = new Stack&lt;&gt;();public interface Comparable&lt;E&gt; {  public int compareTo(T o);}public interface Generator&lt;T&gt; {    T next();}/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;{ * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot; */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;{    @Override    public T next() {        return null;    }}/** * 当实现泛型接口时确定泛型实际类型时，类名就不用再加&lt;&gt;*/class MeetGenerator implements Generator&lt;String&gt;{    @Override    public String next() {        return null;    }}</code></pre><p><strong>泛型方法</strong></p><p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</p><pre><code class="java">/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。(在类上已经定义的泛型类型是可以使用的) *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,IllegalAccessException{        T instance = tClass.newInstance();        return instance;}public class Generic&lt;T&gt;{             private T key;        public Generic(T key) {            this.key = key;        }     //虽然在方法中使用了泛型，但是这并不是一个泛型方法。     //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。     //所以在这个方法中才可以继续使用 T 这个泛型。        public T getKey(){            return key;        }}/**      * 这才是一个真正的泛型方法。     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T     * 这个T可以出现在这个泛型方法的任意位置.     * 泛型的数量也可以为任意多个      */     public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container){ } //当在泛型类中定义泛型方法class GenerateTest&lt;T&gt;{        public void show_1(T t){            System.out.println(t.toString());        }  //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。  //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。        public &lt;E&gt; void show_3(E t){            System.out.println(t.toString());        } //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。        public &lt;T&gt; void show_2(T t){            System.out.println(t.toString());        }    }</code></pre><p><strong>注意！如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法。（否则非法）</strong></p><pre><code class="java">public class StaticGenerator&lt;T&gt; {    /**     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。     * 如：public static void show(T t){..},此时编译器会提示错误信息：          &quot;StaticGenerator cannot be refrenced from static context&quot;     */    public static &lt;T&gt; void show(T t){    }}</code></pre><p><strong>泛型通配符（通配泛型）</strong></p><p><code>Ingeter</code>是<code>Number</code>的一个子类，<code>Generic&lt;Ingeter&gt;</code>与<code>Generic&lt;Number&gt;</code>实际上也是相同的一种基本类型。但是在使用<code>Generic&lt;Number&gt;</code>作为形参的方法中，不能使用<code>Generic&lt;Ingeter&gt;</code>的实例传入。<code>Generic&lt;Integer&gt;</code>不能被看作为``Generic<Number>`的子类。<strong>由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），但是不同版本的泛型类实例是不兼容的。</strong></p><p>所以需要一个在逻辑上可以表示同时是<code>Generic&lt;Integer&gt;</code>和<code>Generic&lt;Number&gt;</code>父类的引用类型。由此类型通配符应运而生。</p><pre><code class="java">FruitGenerator&lt;?&gt; t = new FruitGenerator&lt;&gt;();</code></pre><p>类型通配符一般是使用？代替具体的类型实参，<strong>注意了，此处<code>？</code>是类型实参，而不是类型形参 。此处的<code>？</code>和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类，是一种真实的类型。（不能用于类和方法要使用的泛型的声明，是用在调用和使用上）</strong></p><p>可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p><p><strong>有三种形式的通配泛型，<code>&lt;?&gt;</code>表示任意类型 <code>&lt;? extends T&gt;</code> 表示是T或T的一个子类型  <code>&lt;? super T&gt;</code>表示是T或T的一个父类型    （其中T是泛型类型）</strong></p><pre><code class="java">public void showKeyValue1(Generic&lt;? extends Number&gt; obj){}public &lt;T&gt; void showKeyValue1(Generic&lt;? extends T&gt; obj){}</code></pre><p>具体关系看一下P12的那个图就会清晰了</p><p><strong>原始类型和向后兼容</strong></p><p>没有指定具体类型的泛型类称为原始类型（相当于指定的类型是Object，ArrayList相当于ArrayList<Object>），这是不安全的（编译后会全都消除泛型变为原始类型）</p><p><strong>消除泛型（编译成字节码后就没有泛型了）</strong></p><p>泛型是使用<strong>类型消除</strong>的方式实现的，编译器使用泛型类型信息来编译代码，但随后就会消除它，所以泛型信息在运行时是不可用的（这种方法可以是泛型代码向后兼容使用原始类型的遗留代码）</p><p><strong>一旦编译器确定泛型类型是安全使用的，就会把它转变为原始类型。如果是非受限的，就会使用Object来进行代替；如果是受限的，就会用该受限类型进行替换。</strong></p><pre><code class="java">ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(); String a = list1.get(0)//会变为下面语句ArrayList list1 = new ArrayList();String a = (String)list1.get(0)//要做类型转换（因为现在里面的元素的声明类型都是Object的，所以要显式转换一下）</code></pre><p><strong>注意！不管实际的类型是什么，泛型类被它的所有实例所共享</strong></p><pre><code class="java">ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();list1 instanceof ArrayList  //truelist2 instanceof ArrayList  //truelist1 instanceof ArrayList&lt;String&gt;  //会报错，没有这个类型</code></pre><p><strong>尽管编译时有两种类型，但是在运行时只有一个一个ArrayList类会被加载到JVM中，list1和list2都是ArrayList的实例，但是<code>ArrayList&lt;String&gt;</code>这个类型在运行时是不存在的（不是单独一个类），所以上述instanceof才有以上结果</strong></p><p><strong>对泛型的限制（由于运行时（编译完成后）泛型被消除）</strong></p><ol><li><p>不能使用 new E()</p></li><li><p><strong>可以声明一个泛型类型的数组变量，但不能创建一个确切的泛型类型的数组</strong>，不能使用 new E[] ，也不能用泛型类创建数组<code>ArrayList&lt;String&gt;[] list = new ArrayList&lt;String&gt;[10]</code>是错误的</p><p><strong>（1）可以通过new一个该泛型类的原始类型的数组，然后做一个显式的类型转化（不在这里做的话，就要在取数据的时候要做类型转换）（会有编译免检警告，无法确保运行时类型转换成功）</strong></p><p><strong>（2）使用通配符进行数组创建也是允许的（注意取数据的时候要做类型转换）</strong></p></li></ol><pre><code class="java">List&lt;String&gt;[] ls = new ArrayList[10];List&lt;String&gt;[] ls = new (List&lt;String&gt;[])ArrayList[10];List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10]; List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type.    Object o = lsa;    Object[] oa = (Object[]) o;    List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();    li.add(new Integer(3));    oa[1] = li; // Correct.    Integer i = (Integer) lsa[1].get(0); // OK </code></pre><p><strong>（3）可以使用steam库的toArray()加上Lambda表达式来创建对象数组</strong></p><pre><code class="java">Person[]people = stream.toArray(Person::new):</code></pre><ol start="3"><li><p><strong>在静态上下文中不允许类的参数是泛型类型（静态变量不可是泛型，静态方法要注明）</strong></p></li><li><p><strong>泛型类不能扩展异常（异常类不能是泛型的，因为运行时catch中要匹配类型）</strong></p></li></ol><p><strong>（所有修饰符和关键字保留字整理：修饰符-&gt;  public protected private  static  abstract  final    关键字 保留字-&gt;  ）</strong></p><p><strong>（可访问修饰符决定了父类方法是否可以在子类中 重载 调用！一定注意）</strong></p><p><strong>(所有抽象类和接口中的抽象方法在子类中的实现都相当于方法重写，要加上@override 表明是重写（好习惯）)</strong></p><h3 id="8-枚举类"><a href="#8-枚举类" class="headerlink" title="8  枚举类"></a>8  枚举类</h3><p>有时候， 变量的取值只在一个有限的集合内。为了防止取值超出给定范围，我们可以自定义枚举类型</p><pre><code class="java">enum Size {SMALL, MEDIUM, LARGE, EXTR.ALARCE };//实际上定义了这个类以及4个对象Size s = Size.MEDIUM;//实际上是在赋对象的引用</code></pre><p>Size 类型的变量只能存储这个类型声明中<strong>给定的某个枚举值， 或者 null 值</strong>， null 表示这 个变量没有设置任何值。</p><p>实际上， <strong>这个声明定义的类型是一个类， 它刚好有 4 个实例， 在此尽量不要构造新对象</strong>。 因此， 在比较两个枚举类型的值时， <strong>永远不需要调用 equals, 而直接使用“ = = ”</strong> 就可以了。</p><p>如果需要的话， 可以在枚举类型中添加一些构造器、 方法和域。 当然，构造器只是在构造枚举常量的时候被调用（不是新建而是调用）。</p><pre><code class="java">public enum demo{  DEMO_SUCCESS(1,&quot;成功&quot;),DEMO_FAIL(0,&quot;失败&quot;);//枚举常量  //对应的成员变量的属性值  private Integer code;  private String desc;  //公有的getter  public Integer getCode(){return code}  public String getDedc(){return desc}  //全参的构造方法(当调用某个枚举常量时,会将里面的值对应传递给构造方法为成员变量赋值)  Demo(Integer code,String desc){  this.code = code;  this.desc = desc;  }}</code></pre><p><strong>所有的枚举类型都是 Enum 类的子类</strong>。它们继承了这个类的许多方法。其中最有用的一 个是 <strong>toString， 这个方法能够返回枚举常量名</strong>。 例如， Size.SMALL.toString( ) 将返回字符串“ SMALL”。<br> toString 的逆方法是静态方法 <strong>valueOf</strong> ，<code>Size s = Enum.valueOf(Size,class, &quot;SMALL&quot;);</code>将 s 设置成 Size.SMALL。</p><p>每个枚举类型都有一个静态的 values 方法， 它将返回一个包含全部枚举值的数组。 </p><pre><code class="java">Size[] values = Size.values();</code></pre><p>实际上，如同 Class 类一样， 鉴于简化的考虑， Enum 类省略了一个类型参数。 例如， 应该将枚举类型 Size扩展为 <code>Enum&lt;Size&gt;</code></p><h3 id="9-Lambda表达式"><a href="#9-Lambda表达式" class="headerlink" title="9 Lambda表达式"></a>9 Lambda表达式</h3><p>（数学上，带参数变量的表达式就被称为 lambda 表达式）</p><p>lambda 表达式是<strong>一个可传递的代码块（自带变量）</strong>， 可以在以后执行一次或多次。</p><p>在 Java 中传递一个代码段并不容易， <strong>不能直接传递代码段</strong> 。Java 是一种面向对象语言， 所以<strong>必须构造一个对象， 这个对象的类（接口）需要有一个方法能容纳用Lambda表达式传递的代码。这个时候就要借助接口，通过传递Lambda表达式，创建一个含有这个代码段的接口实例来间接实现代码段传递</strong>。</p><p><strong>lambda 表达式不能独立存在， 总是会转换为函数式接口的实例。</strong></p><p><strong>实际上Lambda表达式就是一段自带变量的代码段，当把它传到函数式接口中实际上它的变量就等价于接口中那个抽象方法的变量，它的方法体就是那个抽象方法的重写。当作为变量传入某个方法时，就默认作为需要的实现该接口的类的实例而被创造（该方法所需要的实例）。本质上就是创建了一个接口的类的实例，并且把Lambda表达式的代码给塞进去了作为实现（实现了代码段的传递）</strong></p><p><strong>（1）Lambda表达式语法规则</strong></p><ol start="0"><li>lambda表达式就是一个代码块， 以及必须传人代码的变量规范。无需指定 lambda 表达式的返回类型。lambda 表达式的返回类型总是会由上下文推导得出</li></ol><pre><code class="java">(String first, String second)-&gt; first.length() - second.length()</code></pre><p>注意！如果一个 lambda 表达式只在某些分支返回一个值， 而在另外一些分支不返回值， 这是不合法的。 例如，<strong>(int x) -&gt; { if (x &gt;= 0) return 1; } 就不合法。</strong></p><ol><li>一种 lambda 表达式形式: <strong>参数， 箭头(-&gt;) 以及一个表达式</strong>。 </li></ol><p>如果代码要完成的计算无法放在一个表达式中， 就可以像写方法一样， 把这些代码放在 {}中， 并包含显式的 return 语句。</p><pre><code class="java">(String first, String second) -&gt;{ if (first.lengthO &lt; second.lengthO) return -1;  else if (first.lengthO &gt; second.length()) return 1;else return 0; }</code></pre><ol start="2"><li>即使 lambda 表达式没有参数， 仍然要提供空括号， 就像无参数方法一样:</li></ol><pre><code class="java">() -&gt; { for (int i= 100; i&gt;= 0; i-- ) System.out.println(i); }</code></pre><ol start="3"><li>如果可以推导出一个 lambda 表达式的参数类型， 则可以忽略其类型。</li></ol><pre><code class="java">Comparator&lt;String&gt; comp= (first, second) // Same as (String first, String second)-&gt; first.length() - second.length();</code></pre><p>在这里， 编译器可以推导出 first 和 second 必然是字符串， 因为<strong>这个 lambda 表达式将赋给一个字符串比较器</strong>。</p><ol start="4"><li>如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号：</li></ol><pre><code class="java">ActionListener listener = event -&gt;System.out.println(&quot;The time is &quot; + new Date()); // Instead of (event) -&gt; . . . or (ActionEvent event) -&gt; . . .</code></pre><p><strong>（2）函数式接口</strong></p><p>对于<strong>只有一个抽象方法的接口</strong>， 需要这种接口的对象时， 就可以提供一个 lambda 表达式。 这种接口称为<strong>函数式接口 (functional interface)</strong>。</p><p>注意！接口不一定有抽象方法。</p><p>一方面，接口完全有可能重新声明 Object 类的方法， 如 toString 或 clone, 这些声明有可能会让方法不再是抽象的。(Java API 中的一些接口会重新声明 Object 方 法 来附加javadoc注释 ComparatorAPI 就是这样一个例子)</p><p>另一方面，在 JavaSE 8 中，接口可以声明非抽象方法（静态方法和默认方法）。</p><p><strong>将Lambda表达式转换为函数式接口的实现对象使用（Lambda表达式的常规用法）</strong></p><p>对于Arrays.sort 方法，它的<strong>第二个参数需要一个 Comparator 实例</strong>， Comparator 就是只有一个方法的接口， 所以可以提供一个 lambda 表达式（相当于实现了这个函数式接口的抽象方法）:</p><pre><code class="java">Arrays.sort (words ,(first, second) -&gt; first.length() - second.length());</code></pre><p><strong>在底层，Arrays.sort 方法会接收实现了<code>Comparator&lt;String&gt;</code>的某个类的对象。在这个对象上调用 compare方法会执行这个lambda 表达式</strong>。</p><p><strong>这些对象和类的管理完全取决于具体实现，与使用传统的内联类相比，这样可能要高效得多</strong>。最好<strong>把 lambda表达式看作是一个函数</strong>，而不是一个对象，另外要<strong>接受 lambda 表达式可以传递到函数式接口</strong>。</p><p>实际上，在 Java 中，对 lambda 表达式所能做的也只是能转换为函数式接口。在其他支持函数字面量的程序设计语言中，可以声明函数类型(如(String,String)-&gt; int)、声明这些类型的变量， 还可以使用变量保存函数表达式。</p><p>甚至不能把 lambda 表达式赋给类型为Object 的变量，Object 不是一个函数式接口。</p><p><strong>在Java中想要用 lambda 表达式做某些处理，还是要谨记表达式的用途，为它建立一个特定的函数式接口。</strong></p><p><strong>Java API 在 java.util.fimction 包中定义了很多非常通用的函数式接口。</strong></p><p>常用的函数式接口：</p><ol><li><code>BiFunction&lt;T, U, R&gt;</code>描述了参数类型为 T 和 U 而且返回类型为 R 的函数。可以把我们的字符 串比较 lambda 表达式保存在这个类型的变量中:</li></ol><pre><code class="java">BiFunction&lt;String, String, Integer&gt; comp= (first, second) -&gt; first.lengthO - second.length();</code></pre><ol start="2"><li>java.util.function 包中有一个尤其有用的接口<code>Predicate</code>:</li></ol><pre><code class="java">public interface Predicate&lt;T&gt;{  boolean test(T t);  //Addition default and static method}</code></pre><p>ArrayList 类有一个 removelf 方法， 它的参数就是一个 Predicate。<strong>这个接口专门用来传递 lambda 表达式（实际上就是将Lambda作为test的实现，是具体的比较逻辑）</strong>。 例如， 下面的语句将从一个数组列表删除所有 null 值:</p><pre><code class="java">list.removelf(e -&gt; e == null);</code></pre><p><strong>（3）方法引用</strong></p><p>使用方法引用和lambda表达式等价</p><p><strong>类似于 lambda 表达式， 方法引用不能独立存在， 总是会转换为函数式接口的实例。</strong></p><p>表达式<code>System.out::println</code> 是一个方法引用(method reference), 它等价于 lambda 表达式<code>x 一&gt; System.out.println(x)</code></p><p><strong>用 :: 操作符分隔方法名与对象或类名</strong>。 主要有 3 种情况: </p><ol><li><strong>object::instanceMethod</strong></li><li><strong>Class ::static Method</strong></li><li><strong>Class ::instanceMethod</strong></li></ol><p>在前 2 种情况中， 方法引用等价于提供方法参数的 lambda 表达式。 前面已经提到， System.out::println 等价于 x -&gt; System.out.println(x)。 类似地， Math::pow 等价于(x，y) -&gt; Math.pow(x, y)。</p><p>对于第 3 种情况， 第 1 个参数会成为方法的目标。例如，String::compareToIgnoreCase 等 同于 (x, y) -&gt; x.compareToIgnoreCase(y)</p><p>如果有<strong>多个同名的重栽方法</strong>， 编译器就会尝试从上下文中找出你指的那一个方法。 例如， Math.max 方法有两个版本， 一个用于整数， 另一个用于 double 值。 选择哪一个版 本取决于 Math::max 转换为哪个函数式接口的方法参数。 </p><p>可以在方法引用中使用 this 参数。 例如， this::equals 等同于 x -&gt; this.equals(x)。 使用 super 也是合法的，比如super::instanceMethod</p><p><strong>（4）构造器引用</strong></p><p>构造器引用与方法引用很类似， 只不过方法名为 new。例如，Person::new 是 Person 构造器的一个引用。选择哪一个构造器取决于上下文。</p><p><strong>构造器引用可以很好地解决无法创建泛型数组的问题</strong></p><p> Stream接口有一个 toArray 方法可以返回 Object 数组，可以把 Person[]::new 传入toArray 方法，toArray 方法调用这个构造器来得到一个正确类型的数组。 然后填充这个数组并返回。</p><pre><code class="java">Person[] people = stream.toArray(Person::new):</code></pre><p><strong>（5）变量作用域</strong></p><p>通常，你可能希望能够在 lambda 表达式中访问外围方法或类中的变量，Lambda表达式可以捕获它所使用的外围方法或类中的变量。</p><p>lambda 表达式有 3个部分：</p><p><strong>（1）一个代码块</strong><br><strong>（2）参数</strong><br><strong>（3）自由变量的值，这是指非参数而且不在代码中定义的变量</strong></p><p><strong>注意！表示 lambda 表达式的数据结构必须存储自由变量的值，我们说它被 lambda 表达式捕获（captured）</strong>（比如可以把一个 lambda 表达式转换为包含一个方法的对象， 这样自由变量的值就会复制到这个对象的实例变量中。）</p><p><strong>关于代码块以及自由变量值有一个术语: 闭包（closure）。在 Java 中，lambda表达式就是闭包。</strong></p><p>lambda 表达式可以捕获外围作用域中变量的值。 在 Java 中，要确保所捕获的值是明确定义的，这里有一个重要的限制。<strong>在 lambda 表达式中， 只能引用值不会改变的变量（比如String），否则无论是在表达中改变这个变量还是变量在表达式外被改变，都会产生严重问题（比如并发执行）</strong></p><p><strong>lambda 表达式中捕获的变量必须实际上是最终变量 ( effectivelyfinal )。 最终变量是指，这个变量初始化之后就不会再为它赋新值。</strong></p><pre><code class="java">public static void countDown(int start, int delay){  ActionListener listener = event -&gt;  {    start--; // Error: Can&#39;t mutate captured variable     System.out.println(start) ;  };   new Timer(delay, listener),start();}</code></pre><p><strong>lambda 表达式的方法体与嵌套块有相同的作用域</strong>。 这里同样适用命名冲突和遮蔽的有关规则。 <strong>在 lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的</strong>，因为在方法中不能有两个同名的局部变量， 因此，lambda 表达式中同样也不能有同名的局部变量。</p><p>在一个lambda 表达式中使用 this 关键字时， 是指创建这个 ambda 表达式的方法的 this 参数。</p><p><strong>（6）处理Lambda表达式</strong></p><p><strong>使用 lambda 表达式的重点是延迟执行（deferred execution）</strong>。 毕竟， 如果想耍立即执行代 码， 完全可以直接执行， 而无需把它包装在一个lambda 表达式中。 希望延迟执行的场景有很多，例如：</p><p>（1）在一个单独的线程中运行代码</p><p>（2）多次运行代码</p><p>（3）在算法的适当位置运行代码(例如， 排序中的比较操作）</p><p>（4）发生某种情况时执行代码(如数据到达、点击按钮 等）</p><p>（5）只在必要时才运行代码</p><p><strong>常用函数式接口：核心技术PDF P256</strong></p><p>最好使用提供的标准的函数式接口，如果设计你自己的接口， 其中只有一个抽象方法， 可以用 <code>@FunctionalInterface</code> 注解来标记这个接口。 这样做有两个优点。 如果你无意中增加了另一个非抽象方法， 编译器会产生一个错误消息。 另外 javadoc 页里会指出你的接口是一个函数式接口。</p><p><strong>Comparator 接口</strong>包含很多方便的静态方法来创建比较器。 这些方法可以用于 lambda 表达式或方法引用。</p><p>静态 comparing 方法取一个“ 键提取器” 函数， 它将类型 T 映射为一个可比较的类型 ( 如 String )。 对要比较的对象应用这个函数， 然后对返回的键完成比较。 例如， 假设有一个 Person 对象数组， 可以如下按名字对这些对象排序:</p><pre><code class="java">Arrays.sort(people, Comparator.comparing(Person::getName));Arrays.sort( people , Comparator.comparing(Person::getlastName) .thenConiparing(Person::getFirstName));···//后面的实在是看不明白了</code></pre><h3 id="10-内部类"><a href="#10-内部类" class="headerlink" title="10  内部类"></a>10  内部类</h3><p>内部类(inner class) 是定义在另一个类中的类。</p><p>使用内部类的原因:</p><p><strong>（1）内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</strong></p><p><strong>（2）内部类可以对同一个包中的其他类隐藏起来。</strong></p><p><strong>（3）当想要定义一个回调函数且不想编写大量代码时，使用匿名(anonymous) 内部类比较便捷。</strong></p><p>嵌套是一种类之间的关系， 而不是对象之间的关系。一个 LinkedList 对象并不包含 Iterator 类型或 Link 类型的子对象。</p><p>嵌套类有两个好处: <strong>命名控制和访问控制</strong>。</p><p>由于Iterator 嵌套在 LinkedList 类的内部， 所以在外部被命名为 LinkedList::Iterator，这样就不会与其他名为 Iterator 的类 发生冲突。在 Java 中这个并不重要， 因为 Java 包已经提供了相同的命名控制。 </p><p>如果将Link内部类声明为private。即使将 Link 的数据域设计为公有的， 它仍然是安全的。 这些数据域只能被 LinkedList 类 (具有访问这些数据域的合理需要)中的方法访问， 而不会暴露给其他的代码。 在 Java 中， 只有内部类能够实现这样的控制。</p><p><strong>（1）内部类基础</strong></p><p>Java 内部类还有另外一个功能， 这使得它比 C++ 的嵌套类更加丰富，用途更加广泛。 </p><p><strong>内部类的对象有一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针， 可以访问外围类对象的全部状态（？）。</strong></p><p>在 Java 中，<strong>static 内部类没有这种附加指针</strong>，这样的内部类与 C++ 中的嵌套类很相似。</p><p>从传统意义 上讲， 一个方法可以引用调用这个方法的对象数据域。 内部类既可以访问自身的数据域， 也 可以访问创建它的外围类对象的数据域.</p><p>内部类的对象总有一个隐式引用， 它指向了创建它的外部类对象，这个引用在内部类的定义中是不可见的。</p><p>外围类的引用在构造器中设置。 编译器修改了所有的内部类的构造器， 添加一个外围类 引用的参数。（当外围类创建一个内部类对象时，就会隐式的将this传给它（编译器自动完成））</p><p>只有内部类可以是私有类， 而常规类只可以具有包可见性， 或公有可见性。（<strong>可以将内部类声明为private，同样的可以声明为public（没有唯一性限制）</strong>）</p><p>表达式<code>OuterClass.this</code>表示在内部类中外围类引用。<code>outerObject.new InnerClass(constructionparameters)</code> 表示内部类的构造器（创建内部类对象时用）</p><p>在外围类的作用域之外， 可以这样引用内部类:<code>OuterClass.InnerClass</code></p><p>内部类中声明的<strong>所有静态域都必须是 final</strong>。 原因很简单。 我们希望一个静态域只 有一个实例， 不过对于每个外部对象， 会分别有一个单独的内部类实例。 如果这个域不 是final, 它可能就不是唯一的。</p><p><strong>内部类不能有 static 方法。</strong>Java 语言规范对这个限制没有做任何解释。也可以允许有静态方法， 但只能访问外围类的静态域和方法。</p><p>内部类是一种编译器现象， 与虚拟机无关。 编译器将会把内部类翻译成用 $ ( 美元符号)分隔外部类名与内部类名的常规类文件， 而虚拟机则对此一无所知。例如， 在TalkingClock 类内部的 TimePrinter 类将被翻译成类文件 TalkingClock$Time Printer.class</p><p>由于内部类拥有访问特权，<strong>可以访问外围类的私有数据</strong>， 所以与常规类比较起来功能更加强大。</p><p>（这样做不是存在安全风险吗? 这种担心是很有道理的。 任何人都可以通过调用 accessSO 方法很容易地读取到私有域 beep。 当然， access$0 不是 Java 的合法方法名。 但熟悉类文件结构的黑客可以使用十六进制编辑器轻松地创建一个用虚拟机指令调用那个方法的类文件。 由于隐秘地访问方法需要拥有包可见性， 所以攻击代码需要与被攻击类放在同一个包中。）</p><p>合成构造器和方法是复杂令人费解的（所以就先不看了）</p><p><strong>（2）局部内部类（在方法中定义的内部类）</strong></p><p>只有一个方法使用该内部类时，可以将这个内部类在方法中声明。</p><p>局部类<strong>不能用 public 或 private</strong> 访问说明符进行声明。它的作用域被限定在声明这个局部 类的块中。</p><p>局部类有一个优势， 即<strong>对外部世界可以完全地隐藏起来</strong>。 即使 TalkingClock 类中的其他 代码也不能访问它。除 start 方法之外， 没有任何方法知道 TimePrinter 类的存在。</p><p>与其他内部类相比较， 局部类还有一个优点。 <strong>它们不仅能够访问包含它们的外部类， 还 可以访问局部变量</strong>。 不过， 那些<strong>局部变量必须事实上为 final才能访问。 这说明，它们一旦赋值就绝不会改变。</strong></p><p><strong>（3）匿名内部类</strong></p><p>将局部内部类的使用再深人一步。假如只创建这个类的一个对象， 就不必命名了。这种</p><p>类被称为匿名内部类(anonymous inner class)。通常的语法格式为:</p><pre><code class="java">new SuperType(construction parameters) {inner class methods and data}</code></pre><p>其中，SuperType 可以是 ActionListener 这样的接口， 于是内部类就要实现这个接口。 SuperType 也可以是一个类， 于是内部类就要扩展它。</p><p>由于构造器的名字必须与类名相同， 而匿名类没有类名， 所以， 匿名类不能有构造器。 取而代之的是， 将构造器参数传递给超类(superclass) 构造器。<strong>尤其是在内部类实现接口的时候，不能有任何构造参数（因为接口没有父类）</strong>。</p><pre><code class="java">new InterfaceType(){methods and data}</code></pre><p><strong>（4）静态内部类</strong></p><p><strong>当使用内部类只是为了把一个类隐藏在另外一个类的内部， 并不需要内部类引用外围类对象。为此，可以将内部类声明为static, 以便取消产生的引用。</strong></p><p>在内部类不需要访问外围类对象的时候， 应该使用静态内部类。 有些程序员用嵌套类(nestedclass) 表示静态内部类。</p><p>与常规内部类不同， 静态内部类可以有静态域和方法。</p><p><strong>声明在接口中的内部类自动成为 static 和 public 类。</strong></p><h3 id="11-代理"><a href="#11-代理" class="headerlink" title="11 代理"></a>11 代理</h3><p>利用代理可以在运行时创建一个实现了一组给定接口的新类 : 这种功能只有在编译时无法确定需要实现哪个接口才有必要使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java语法基础</title>
    <link href="/2021/02/25/Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/02/25/Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="Java语法基础笔记"><a href="#Java语法基础笔记" class="headerlink" title="Java语法基础笔记"></a>Java语法基础笔记</h3><p><strong>1 编译与执行</strong></p><p>java源代码（.java）&lt;（java编译器编译）&gt; </p><p>java字节码（.class）+  库代码  &lt;JVM执行（Java解释器）&gt;</p><p> <strong>2 从控制台输入输出</strong></p><p>System.out（in）表示标准输入输出设备</p><p>使用Scanner类创建对象进行读取</p><p>Scanner input = new Scanner(System.in); //将System.in引用值赋给input</p><p>然后通过调用Scanner的方法获取input的值</p><p>double a = input.nextDouble();//读取时以空格或者回车键为分隔</p><p><strong>3 命名常量</strong>（大写所有字母）（用final修饰符）（这是方法中局部变量的常量）</p><p>final int PI = 3.14;</p><p><strong>4 Java8种基本数据类型</strong></p><p>带符号整数（符号占一位）：byte 8  short 16  int 32 long 64</p><p>IEEE754标准浮点数：float 32  double 64（复习下IEEE754）</p><p>boolean  1位  true 或 false  都是直接量 保留字</p><p>char 16位 存储Unicode码</p><p>（其实还有void 但不可以直接操作）</p><p><strong>5 算术操作符 &amp; 关系操作符</strong></p><p>五种算术操作符 “ + - * / % ”    Math.pow(a,b) 幂运算</p><p>六种关系操作符</p><p>四种逻辑操作符   ! 非   &amp;&amp; 与   || 或   ^异或（等同p1 != p2）</p><p>操作符优先级：</p><p>一定先计算括号里面的运算！！！（尤其是涉及到和字符串一起操作的时候）</p><p>同一级别的自左到右结合进行计算</p><p>其他的看一下优先级表（赋值最低  ! 在运算前  其他逻辑和关系都在运算后）</p><p>5.0/9 和 5/9结果不同！</p><p>增强赋值操作符 +=  在表达式中所有其他操作符计算完成后执行  既是赋值语句也是赋值表达式</p><p>use（x += 9+9*7）</p><p>自增自减 ++ – </p><p>j = 10 * i++ 先计算后++  </p><p>j = 10 * (++i) 先++后计算</p><p>三元运算符（唯一）</p><p>x = 布尔表达式 ？表达式1 : 表达式2 （为真执行1 为假执行2）</p><p><strong>6 数值直接量</strong></p><p>超过int范围的直接量后面要加“L”（表示是long类型）</p><p>表示一个二进制直接量使用“0B”开头，八进制直接用0，十六进制用“0X”</p><p>0B1111  07777  0XFFFF</p><p>带小数点的数值默认是double类型的，后面加上f或F才表示是float类型的</p><p>科学计数法  123.456  1.23456E2（或E+2）（表示10的2次方）0.0123  1.23E-2</p><p>数值之间可以用下划线隔开  231_453_234L</p><p><strong>7 类型转换</strong></p><p>小范围变大范围（拓宽类型）  Java会自动拓宽</p><p>大范围变小范围（缩窄类型）必须显式完成</p><p>记住！浮点数的范围比整数大得多，虽然float只有32位，但是比64位的long表示范围大（3.4E38  double是1.7E308 而long只有0.9E19 int 0.2E10），long型可以直接赋给float</p><p>显示转换   (int)1.7   -&gt; 1    (double) 1/2   -&gt; 0.5</p><p>注意！x1 op= x2 的形式自带显式转换，运算完会转换成x1的类型</p><p><strong>8 溢出问题</strong></p><p>java中如果变量被赋予一个过大的值，就会溢出，但是Java不会给出警告或报错！只是你的值会变得不正确。</p><p>对于整数，如byte -128到127  127+1 -&gt; -128  -128-1 -&gt; 127（原码理解就可以）。对于浮点数，很接近0会向下溢出，Java会将其近似为0</p><p><strong>9 取整错误</strong></p><p>涉及浮点数的的计算都是近似的，所以在==时可能会遇到问题，要注意一下</p><p>还有double s = （2 + 3）/ 2 执行的是整数除法  只有（2+3）/ 2.0 才是对的</p><p>10  if  switch</p><p>switch(表达式){</p><p>case 0 : XXX;</p><p>break;</p><p>…………</p><p>default : XXX;</p><p>}</p><p><strong>11 常用的数学函数和random方法</strong></p><p>Math.方法(数值)</p><p>Math.random() 返回一个0.0-1.0之间的double（不包括1.0）（只有一位小数？）</p><p>返回一个区间的随机整数  a + （int）(Math.random() * b)  (a到a+b这个区间的一个随机整数，不包括a+b)</p><p><strong>12  char类型</strong></p><p>char有16位，可以存放一个Unicode码</p><p>Java支持Unicode</p><p>Unicode码  16位  用 /u开头的4位16进制表示  从/u0000到/uFFFF对应128个ASCII码</p><p>ASCII码  8位（只用7位来表示）常用  0-9  48-57  A-Z  65-90  a-z  97-122（数值对应）</p><p>char可以自增自减</p><p>转义字符 \    \n换行  \r 回车  \\   \“</p><p>char与任意数值类型可以相互转换（要显式转换）。</p><p>浮点数会先转换成int，整数类型会截取低16位进行存储</p><p>char转数值，会转成对应特定数值</p><p>0-FFFF任意一个正整数都可以隐式转成char，其他的必须显式声明</p><p>所有数值操作符都可以用在char上，char会自动变成数字，如果是字符串，就会将这个char连上去（数值也可以直接和string相连，j=99  j+”abb”  -&gt; 99abb）</p><p>char也可以直接用关系操作符比较</p><p>Character类提供了一些字符处理方法</p><p><strong>13 String类型</strong></p><p>java库中预定义的类，不是基本类型而是引用类型</p><p>实例方法   静态方法</p><p>“”表示空字符串，其length为0</p><p>Scanner的next()方法读取以空白字符结束的字符串</p><p><strong>14 基本字符串函数（可以看看源码实现）</strong></p><p>charAt(index) 提取特定字符，0到size-1   注意不要越界</p><p>substring(beginIndex,endIndex)  截取字符子串，可以没有endIndex</p><p>获取字符或子串的下标的方法 （last加了这个前缀就是从后向前找，不加就是从想象后）indexOf(ch/s1,FromIndex(可以没有))</p><p>trim()用于删除两端空白字符（包括一些转义字符）</p><p>直接使用 + 进行字符串连接 +=也支持</p><p>字符串和数字或者char连接都是直接连接，注意也是左结合的，有括号先算括号</p><p>== 与equals的区别，涉及到堆栈的问题</p><p>不能使用  &gt;  &lt; 来比较字符串 用compareTo(s2) 来代替 （equals返回true false 而这个是逐个字符比较，返回 正数 0 或者负数）</p><p>contains(s2)判断是否是子串</p><p>可以用XXIgnoreCase(s2) 来忽略大小写</p><p>starts/endsWith(s2)</p><p>字符串可以与数字间相互转化</p><p>int  num = Integer.parseInt(“123456”);（num就是123456） （double的字符串数值也可以用Double.parseDouble(“123456”)来实现）</p><p>数值转字符串直接   String s1 =  数值+””;  即可</p><p><strong>15 循环 while  do-while for</strong>  </p><p>foreach  用于遍历数组   for（元素类型  e : 数组变量）顺序遍历数组中每一个元素</p><p><strong>16 输入 输出重定向</strong></p><p><strong>17 方法 包括方法头和方法体</strong></p><p>方法头包括  修饰符（public protected private ； static  可以都有）  返回值类型  方法名  参数列表</p><p>方法体  处理逻辑  返回值</p><p>形参  实参（调用时）</p><p>main方法由Java虚拟机调用</p><p>调用方法时会创建一个活动记录（活动框架），用于保存方法中的参数和变量。活动记录位于一个内存区域，称为<strong>（调用、执行、运行时）堆栈（call stack）</strong>，当一个方法调用另一个方法，调用者的活动记录保持不动，一个新的活动记录被创建于被调用的新方法（<strong>本质是一个stack，一个方法调用给一块空间，先进后出</strong>）</p><p>当调用放回时，空间被释放（这一块要去看一下JVM，看一下底层是怎样实现的）</p><p><strong>Java只有一种传参方式  按值传递（pass by value），当方法调用时将实参的值传给形参，形参的变量是独立的，不影响实参本身（引用变量不是）（这个要结合引用和复制）</strong></p><p><strong>18 方法重载</strong>   有相同的方法签名  但有不同的参数列表（但要注意不要歧义调用）</p><p><strong>19 方法抽象</strong>（将使用和实现分离）和逐步求精（分治思想）</p><p>自顶向下设计  -&gt; 自顶向下和自底向上的实现</p><p><strong>20 数组</strong></p><p>元素类型 [] 变量名 = new 元素类型[数组大小];</p><p>（1 使用new 创建了一个数组并分配内存空间  2 将这个数组引用赋给变量）</p><p>数组变量存储了指向数组的引用（内存地址）</p><p>所有数组元素都有默认值，0  \u0000  false</p><p>匿名数组（在方法调用实参直接new数组   new []{   }  ）</p><p>数组的复制（）  数组的传递（传递的是引用）</p><p><strong>JVM将对象存储在  堆（heap）中，堆用于动态内存分配</strong></p><p>在程序运行时，会将数组创建于堆中，而方法被调用时，变量会存在栈中</p><p>方法返回的数组实际上是传的是数组的引用</p><p><strong>可变长参数列表</strong>  方法名(XXX,变量类型…变量名)  必须是最后一个变量，代表是可变长参数，Java将其看做数组处理  调用的时候可以<strong>传入一个不定长的参数头</strong>，或者直接传一个数组  （  pixi（XXX, 34,4,5,5.5）或者  pixi（XXX,new []{}））</p><p>Arrays类是util工具类中对数组的一些方法  尤其是sort和parallelSort（要看下JDK的实现源码）</p><p>toString(s1)  返回一个字符串，包含数组所有内容</p><p>equals(s1,s2)检测两个数组内容是否相同</p><p><strong>main方法实际上就是一个静态的、参数是字符串数组的普通方法。main方法可以被其他类的方法调用（因为是 public  static void 的）当调用main的时候，Java解释器会new一个数组存储  命令行参数  没有参数会创建一个length为0的数组，而不是null！</strong></p><p><strong>问题：匿名数组和数组直接量有什么区别？尤其是在方法传参的时候（会不会Java解释器自己创建一个数组来存储命令行参数，然后再传给方法？）</strong></p><p><strong>21 多维数组</strong></p><p>元素类型 [] [] 数组名  =  new  元素类型 [行数量] [列数量]</p><p>初始化  = { {……} {……} {……} } ;（一行一行的）</p><p>x[0]  x[1]  x[2] 都是一个一维数组的引用  一个框是引用  两个框是地址</p><p><strong>锯齿数组  各行长度不同的数组，可以new行数，这样就给定了第一维的地址空间，然后再分别new每一行的数组的长度（实际上和邻接表很像，只是第一维的数组的元素不是链表，而是顺序表） int [][] array = new int[行数][]   然后每一行 array[0] = new int[每一行的个数]</strong></p><p>传递二维数组，返回二维数组的引用  int [] [] array </p>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日程安排</title>
    <link href="/2020/10/04/%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92/"/>
    <url>/2020/10/04/%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<h2 id="各科目各阶段复习方式方法"><a href="#各科目各阶段复习方式方法" class="headerlink" title="各科目各阶段复习方式方法"></a>各科目各阶段复习方式方法</h2><p>α  先把最艰苦的第一阶段给熬过去，必要的时候必须Rush一波，必须既要保证进度也要确保质量。按时间规划完成这个阶段你才真正有资格去参加考研的竞争。</p><h3 id="总体框架（大致划分）"><a href="#总体框架（大致划分）" class="headerlink" title="总体框架（大致划分）"></a>总体框架（大致划分）</h3><p>2020.9.2-2020.9.21  阶段α</p><p>9月中下旬到10月底  阶段β</p><p>10月底到11月底  阶段γ</p><p>11底到考前  阶段Ω（考前留一周左右出来综合复习）</p><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>第一阶段基础巩固（9.02-9.20 20开始强化）（也就是说到下周日（因为要考四六级所以20号也算进去））</p><p>从8号开始，每两天一个线代课程，多出来的时间做课本的题（不用全做完）</p><p>9号完成第二章的题目和整理，完成第一章两个题型的整理，然后以两天一章的进度把基础题目和章节整理搞完（可以均匀分配一下时间，必要时要Rush一下，这个时间不能再拖了）</p><p>方法（线代）：</p><p>1  先刷一遍课本，例题做一下，整理出一个知识点和定理公式题型结构出来，大致理解</p><p>2  刷视频，记笔记做例题，然后把没有的补充上去，完全理解</p><p>3  如果有剩余时间就挑着刷一下课后题，熟练题型（没时间就算了）</p><p>方法（高数）：按照我们之前说的</p><p>1 整理知识点，搞出一份A4纸的知识提纲，复习基本知识</p><p>2 开始做题，整理一个计算和常用知识表，把题目做完改完，并归纳题型（并加入处理队列）</p><p>3 按照处理队列 将题型和题目归纳整理到整理本上，做到对应的不会再错，最后归纳一下考查方式</p><p>part One：回顾整理  刷题  改错</p><p>part Two：计算表  题目归纳整理  易错知识点和考查方式归纳整理</p><p>从21号开始进入强化，此时的基本概念和公式必须全部记熟并灵活应用，所有基础的题目必须全部做完、改完、整理完。强化阶段30天，完成强化课程以及笔记，强化题目（加上660 强化选择填空）的完成、改错和整理，并且将基础部分错的题再刷一遍。完成这些之后10月21开始下一阶段，着手真题以及加一些辅助性教材和题目以及视频（如李林108以以及武忠祥17讲等）</p><h3 id="专业课"><a href="#专业课" class="headerlink" title="专业课"></a>专业课</h3><p>第一阶段</p><p>A Week A Book</p><p>A Day A Chapter</p><p>数据结构 8章（6/8）</p><p>计算机组成原理 7章（0/7）</p><p>操作系统 5章（0/5）</p><p>计网 6章（0/6）</p><p>方法：</p><p>（1）完成王道的一刷，和知识结构的整理（每章列个清单）</p><p>（2）将所有的选择和部分大题搞定并改错</p><p>（3）完成以上的笔记整理（只整理结构和难点以及错题和题型，不要抄书）</p><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>（第一阶段  到10月之前）</p><p>词汇：每天400个，再加上每天2篇阅读整理的复习</p><p>语法：每天一小节，有意识的去看去用</p><p>练字：每天练上十分钟的字</p><p>阅读精读：每天两篇阅读加整理，把英一的和留下5年英二的，其他都做完并整理，把唐迟的技巧课（10节，基本每两天一节就可以）看完并做笔记。如果有的很难理解去看看对应的课程</p><p>小三门（第二阶段再考虑）</p><p>作文（第二阶段再考虑）：四六级之前看个视频+整理一波，有个基础</p><h3 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h3><p>中午和晚上吃饭的时候看视频课，1.5倍速就可，记得记一下结构和关键点就可以，重要事有个框架概念以及认识理解（一个月左右看完，稍微长一点也没关系）</p><p>精讲精练和1000题配套做，10月份刷完第一遍（和视频课速度对应）（材料分析可以不写，把思路写出来即可，然后去按答案修改思路）</p><p>具体时间安排：</p><p>每天中午和晚上吃完饭看政治的视频，每天至少看连个课时，并且完成对应的精讲精练以及1000题（10月底之前完成所有视频课笔记以及精讲精练和1000题一刷）</p><hr><h2 id="Final-Framework-Plan"><a href="#Final-Framework-Plan" class="headerlink" title="Final Framework Plan"></a>Final Framework Plan</h2><h3 id="数学-1"><a href="#数学-1" class="headerlink" title="数学"></a>数学</h3><p>9.02-9.28 完成基础篇的综合整理，整理出计算表，记熟所有定理，公式以及题型和解法，完成线代基础部分（做到基本都能做的程度）（模拟一次，查验一下水平）</p><p>9.29-10.26 完成强化课程 重刷和完全整理基础的错题（一周） 强化篇题目 以及660 （3周）（做到基本都会做的程度）</p><p>10.26-11.25 完成近20年真题，并且针对错题进行查缺补漏，适应题目题型（做到基本都能做对的程度）</p><p>11.25-考前  做模拟卷，真题二刷，做之前的错题（做到万无一失的程度）</p><h3 id="专业课-1"><a href="#专业课-1" class="headerlink" title="专业课"></a>专业课</h3><p>9.02-10.10 完成一刷（基本知识结构与大部分题目 以及简单结构笔记）（会做）（模拟一次，查验一下水平）</p><p>10.07-11.01 完成二刷（具体到每一个细节，完全掌握，所有题目）（熟练）</p><p>11.01-11月底 完成408真题以及三刷（哪里不会不熟补哪里）（完全）</p><p>12月初 开始做模拟题并查缺补漏（做到万无一失）</p><h3 id="英语-1"><a href="#英语-1" class="headerlink" title="英语"></a>英语</h3><p>9.20-10.16（四周）1所有单词背诵  2语法掌握（一周刷一遍） 3阅读一刷和整理 4阅读的课程 （<strong>把阅读给搞通</strong>）</p><p>10.16-11.05   1小三门视频课 2 小三门一刷  6 作文课程  7作文基本准备 + 两天一篇阅读</p><p>11.05-12.01  二刷=三刷真题，训练作文、总结方法和经验，查缺补漏</p><h3 id="政治-1"><a href="#政治-1" class="headerlink" title="政治"></a>政治</h3><p>10月底之前完成一轮（每天三个视频，看完一章完成一章的精讲精练和1000题）</p><p>11月之后二刷1000题，开始背疾风劲草和答题整理，看完冲刺班，开始定期模拟训练</p><p>12月初  反复背诵，看错题，开始刷模拟题</p><p>（我们必须定期休息，注意调整，然后定期注入一些新的动力，避免低迷期影响效率和进度。）</p><h3 id="休息的方式"><a href="#休息的方式" class="headerlink" title="休息的方式"></a>休息的方式</h3><p>生理上要保证充足的睡眠以及每日适量的运动（俯卧撑+深蹲+提纲+跑步（可以两天一次）），每周休息的半天可以进行外出（吃点好的）。</p><p>心理上我们要注意，每天和同学父母交流一下。一旦陷入低迷期，我们要去三楼看一些书，找个地方做一下。每周休息的半天可以外出看个电影，适当放松（玩局游戏）.</p><p>平时当遇到脑子很胀，不清醒，效率很低的时候不要去耍手机或者硬撑。可以趴下睡一会，然后会好很多。</p><p>发现适当的饥饿感可以让人保持清醒，以后吃036的饭，不要吃太饱，不利于效率</p><hr><h3 id="过程目的"><a href="#过程目的" class="headerlink" title="过程目的"></a>过程目的</h3><p>之前一个月，第一阶段，我们积累了相应的基础，可以控制，但是没有解决连贯性的问题，在第二个阶段我们要完成连续性的问题，去除所有杂质，形成一个循环回路，达到主动自律；第三个阶段将这个循环稳固下来，然后完全适应，达到被动自律；第四阶段你要完全内化，形成习惯，让自律和自我掌控成为你的固有属性（完美执行）</p><h3 id="跨越目的（各阶段）"><a href="#跨越目的（各阶段）" class="headerlink" title="跨越目的（各阶段）"></a>跨越目的（各阶段）</h3><p>从周二晚上开始Rush一波，一直到下周一下午，完成预期所有目标，然后休息一晚上</p><p>我们要和少校一样，以任务为绝对重心，以客观事实为重，将任务置于最高，不以你的意志为转移的完成既定目标。</p><p>还剩下三个月整了，还没有完全复习一遍，接下来必须要Rush一波了，无论怎样都要完成当天的任务，没有商量和妥协的余地（<strong>从25号开始，每天必须完成规划的所有任务才可以睡觉，所以不想熬夜就给我提高效率，注意，这是命令而非请求，你必须记住，一切都是为了最终的胜利，我们必须要拿下这场战役的胜利，否则就会失去一切！</strong>）</p><h3 id="高效率安排复习课目，保证每日任务保质保量高效完成"><a href="#高效率安排复习课目，保证每日任务保质保量高效完成" class="headerlink" title="高效率安排复习课目，保证每日任务保质保量高效完成"></a>高效率安排复习课目，保证每日任务保质保量高效完成</h3><p>上午做数学是一种愚蠢的行为，因为状态不好你完不成对应目标你就会一做做一天，所以每个阶段开始的时候先处理容易完成的，早上就从英语开始，下午可以先处理一下政治，带书至少要带两门，一个状态不好的时候立刻切换为另外一门，保证时间的充分利用和时间的效率问题。政治和英语每天的任务量是恒定的，专业课也是，可以与数学相互切换，让所有时间都高效起来。以后上午开始先搞英语，中午和晚上必须把徐涛看完，笔记可以简写，下午开始可以先学一会政治，晚上开始先练字并且背一下语法。上午状态好就高数，不好就专业课。晚上处理线代。专业课高效搞完剩下的时间都是高数的，做不完就熬夜。要先保证容易的，不会拖时间的，每日都要积累的东西先完成，困难的放到效率高，有状态的时候做。这样既可以保证英语政治专业课每日的任务都有完成和积累，又可以确保数学在效率高、状态好的时间完成，并且即便未完成最后也只会剩下数学，处理难度和复杂度降低。<strong>一定要避免这几天做高数状态不好一做做一天的这种情况，安排要灵活，转台不好要及时更换，以完成及可能多的科目任务为目标去进行复习</strong></p><p><strong>如果有未完成的高数，就必须11：30后熬夜完成再睡觉，但是不能影响第二天的早起，所以请尽可能的保证高效，保证你的睡眠和精神状态不受影响。持续性的熬夜会对健康和复习效率有很大的破坏作用，所以不能连续熬夜，必须间隔一天，这也是一个限制</strong></p><p><strong>每一天都必须打起精神来，必须要拼命了，不能再优哉游哉了，只有三个月了，每一分每一秒都要紧张起来，全面投入进去，不要花了时间但没有效果，一旦感觉效率下降，就趴下休息一下，或者起来走走，给自己一些心理暗示，让自己沉浸进去</strong></p><h3 id="心态与计划执行"><a href="#心态与计划执行" class="headerlink" title="心态与计划执行"></a>心态与计划执行</h3><p><strong>我们每天学习时的心态要调整，放轻松一点，不要时时刻刻紧绷着。要以一种尽我最大可能去尽可能多心态去完成计划的任务，而不是充满压抑的，时时刻刻想着赶紧处理完这个还有多少多少东西要做。每完成一件任务的时候应该是快乐满足的，而不是想着还有多少，或者是哪里哪里不满意，充满压抑与焦虑的。要保持乐观向上的心态，要保持微笑，不要成天情绪低落，散发负能量。</strong></p><p>我们要改变状态和心态，首先要改变的就是我们日常安排的<strong>计划与反馈机制</strong></p><p>一直以来，我们实际上是处于一种<strong>负反馈机制</strong>之中，我们给自己规划了超负荷的任务，然后不断给自己心理暗示去完成它，但是实际效率比预想的要低，或者出现任何意外情况，没有按照你的计划那样发展，脱离了控制，你的实际处理的任务量一旦小于目标，你就会陷入一种自我怀疑和焦虑之中，然后在这个不好的状态下再去处理剩下的事，结果负面情绪越积越多，任务完成的远小于目标，事情然后过不了几天，整个计划就会因为你自己的崩溃而崩溃，这就是以往你计划失败的一个很重要的原因。（<strong>容错率太低，负反馈太多，整个人长期处于焦虑和失望的状态之中</strong>）</p><p><strong>规定超额的任务 -&gt; 心理暗示，强迫自己必须每个任务都全部按时完成，开始处于焦虑 -&gt; 效率低于预期或者有意外发生 -&gt; 一旦一项或几项任务没有按照预期发展和完成 -&gt; 开始陷入失望和自我怀疑和持续焦虑，状态变差，但又强迫自己继续去做 -&gt; 在焦虑中低效完成剩下的任务，离目标差的越来越多 -&gt; 一天结束，不仅任务没完成，还收获了满满的负面反馈和焦虑状态  -&gt; 持续几天，长期处于这种状态会让你崩溃，计划随之破产</strong></p><p>所以在剩下的三个月中，我们要建立一种<strong>正反馈机制</strong>，就是<strong>改变心态，将必须按时完成的强迫性的压抑的心态  转变为  尽我最大可能的去完成任务的一种积极乐观的心态</strong>。这种心态下，我们能够通过计划的执行<strong>不断地获得正反馈，即便完不成，但也是我们尽最大努力去做了，也做到了学到了很多，没有一分钟是浪费了的</strong>，然后不断调整和分配，使得计划越来越合理，让自己处于一种<strong>虽然辛苦劳累，但收获满满，每天都乐观积极的去做，每天充满着期待与希望</strong>的状态。<strong>每一天都过得很充实和满足，并且期待明天的到来</strong>，我希望你可以改变心态，做到这一点。（至少每天可以做到不自觉的面带笑容）</p><p>一时半会可能很难彻底改变，但我们可以从小的地方做起</p><p><strong>（1）每天布置任务的时候可以划分几个层次，哪些是必须做完的，哪些是尽可能做完的，这样会使你更有动力（一共3个层次  标明  必要   Rush（完成所有其他之后再做的，不限定，能做多少做多少））</strong></p><p><strong>（2）要乐观开朗一点，不要沉闷，多想想美好的事情，休息的时候让心情放松一下。至少要做到可以面带微笑。</strong></p><p><strong>（3）</strong></p><h3 id="对于各个科目复习的态度和要求"><a href="#对于各个科目复习的态度和要求" class="headerlink" title="对于各个科目复习的态度和要求"></a>对于各个科目复习的态度和要求</h3><p><strong>英语和政治：（扎实积累  稳中求进  达成质变）</strong></p><p><strong>“保证每天的一定时间和积累量，弯沉谷底鹰计划，这是底线，不能让步”</strong></p><p><strong>这两个科目是积累性的科目，必须保证每天的复习时间和任务量的完成，必须把每天的积累量完成，然后按照复习的规划，一点一点提高水平，不能因为数学和专业课而抢占了他们的复习时间。要按照计划，每天完成对应的任务量，不断积累，最后达到一个不错的水平，考试的时候拿到一个满意的成绩</strong></p><p><strong>数学：</strong></p><p><strong>专业课：</strong></p><h3 id="对于休息的要求（不能脱节，更不能破坏！）"><a href="#对于休息的要求（不能脱节，更不能破坏！）" class="headerlink" title="对于休息的要求（不能脱节，更不能破坏！）"></a>对于休息的要求（不能脱节，更不能破坏！）</h3><p><strong>前提：绝对不能熬夜和做有损精神状态的事情，即便是有可能的条件，你应该将这两者从你的生活和习惯中剥离！！！（不能破坏循环的建立，也不能够影响复习！剥离掉这些杂质！）（这不是休息，这是破坏和损坏！）</strong></p><p>适当的休息是必要的，但是其实是没有那么多需要修的时候，很多时候咬咬牙就过去了。</p><p><strong>即使是休息，也不能脱离复习状态，与复习脱节，必须一切以复习为中心。即便休息也不能丢了状态。</strong></p><p><strong>不可以全面放松。</strong>不可以拿出一整天休息，到处去玩，这是绝对不行的，想想就知道，你怎么会有心情去到处压马路；如果你开心的去玩了，那说明你的自我中心就不在复习上了，脱离复习状态和而再次进入复习状态都需要很长时间，这所付出的代价就高的离谱</p><p><strong>可以有限休息。</strong>就拿出一下午或者一晚上调整状态，适当放松，然后以更饱满的精神状态投入复习。（其实就是缓解一下紧张的精神和舒缓压力）。但最多一到两周一次。（尽可能的少一些，感觉到极限了再休息）</p><p><strong>从现在到考研结束，不能再出现30号晚上的那种情况，不能熬夜和做有损精神状态的事情。并且在黑荆棘执行完成以后，这两者也应该从你的生活和习惯中剥离。</strong></p><h3 id="如何控制欲望并将其转化为正向力量以及防止熬夜发生的方法（长期课题）"><a href="#如何控制欲望并将其转化为正向力量以及防止熬夜发生的方法（长期课题）" class="headerlink" title="如何控制欲望并将其转化为正向力量以及防止熬夜发生的方法（长期课题）"></a>如何控制欲望并将其转化为正向力量以及防止熬夜发生的方法（长期课题）</h3><p>###（如何找到正确的压力释放机制并且建立正向循环以及杜绝自我放松和借口）</p><p>十月开始这两天给你造成了很大的冲击。因为你自己的原因导致了一次崩溃，以及循环的破坏。你熬了两天的夜，并且沉迷于欲求。</p><p>1  经验表明，一旦你熬夜以后，第二天你就变得没有办法正常工作和学习，会从日常的自律框架中脱离出来，变得颓废而且失去理智。</p><p>2  这一过程是渐进性的，比如上午还是处于复习状态，下午和晚上就渐渐因为精力不济而失去维持的想法，开始自暴自弃，并且极大概率会再次熬夜。</p><p>3  并且一旦这种势头没有在前两天及时止住的话，这种可怕的状态就会一直持续下去，就像你在家里一样，40多天就那么荒废掉了。</p><p>而熬夜的原因很简单，因为小豪不在，你给自己了可以稍微放纵的心理暗示。其实一开始并没有想熬夜，但是因为吃了零食睡不着，加上这个心理暗示，便一发不可收拾了。所以其实内心的欲求才是熬夜最根本的原因。所以，我们要分析和讨论如何通过某种方法控制和转化欲求以及如何防止熬夜的发生。</p><p>1（关于压力处理）</p><p>首先要承认的是，我们没有很好地压力处理手段，根本原因在于我们没有什么爱好以及生活的乐趣。在高强度的学习和工作中，我们精神上和生理上积累了大量的疲倦，一旦我们像30号那样感觉难以为继，我们的自律周期就有可能被打破，而形式就是熬夜和做有损精神的事情，来释放压力，从意识上脱离束缚。（<strong>我们要有一套更好的压力处理机制，剥离掉这种不经济且有损伤的做法，让自律框架可以循环起来</strong>）</p><p>2（关于自我要求）  </p><p>永远不要给自己任何不睡和熬夜的理由，把这个作为一个不可违反的底线。不要在深夜吃东西，熬夜是不允许发生的。</p><p>永远不要给自己放松的理由，不要一遇到什么问题就想着放弃。比如刷上一小时知乎就觉得今天上午完不成预定目标了，不如休息吧。这是最可怕的。即便你浪费了再多，你不做就是什么也没有，你做一点就是一点。所以不要给自己任何放松的理由。用尽每一个可能的时间去做，不要找任何借口来逃避和放松，那是懦弱的表现，不要想着补回来，也不要想着不如放松一下。而是尽可能的在接下来的时间努力去做就可以了。</p><p>感觉没状态就趴下睡一会，不要玩手机刷知乎</p><p>3（关于欲求）</p><p>4（关于新的方法）</p><hr><p>###阶段1（基础）阶段2（强化）阶段3（真题）阶段4（综合）</p><h3 id="阶段1-复习总结"><a href="#阶段1-复习总结" class="headerlink" title="阶段1 复习总结"></a>阶段1 复习总结</h3><p>没有完全进入状态，复习进度一塌糊涂。需要第二阶段-α 将没有完成的部分完全补齐，然后将强化进行完</p><h3 id="剩余3个月（3个阶段）的整体复习框架"><a href="#剩余3个月（3个阶段）的整体复习框架" class="headerlink" title="剩余3个月（3个阶段）的整体复习框架"></a>剩余3个月（3个阶段）的整体复习框架</h3><p><strong>高数：</strong>8（完成强化课程+1800基础篇和辅导讲义整理 <strong>基本知识架构&amp;方法+题型&amp;解法</strong>）  20（完成提高篇题目+660  <strong>熟练度+计算量</strong>）  ONE（真题一刷+错题重刷）  ONE（真题二刷+模拟题+错题重看）</p><p><strong>线代：</strong>25（完成强化课程和讲义以及660） ONE  ONE</p><p><strong>英语：</strong>15（阅读搞通）20（小三门+作文+阅读训练）ONE（二刷真题—+作文）20（三刷）</p><p>（单词每天400+-100  语法和笔记一周一轮 ）</p><p><strong>专业课：</strong>10（一刷）  ONE（二刷）  20（真题+三刷） 25（模拟题+三刷）</p><p><strong>政治：</strong>ONE（强化课+精讲精练+1000题二刷）  ONE（刷题班&amp;冲刺班+疾风劲草背诵+刷大题和1000题三刷+模拟） 25（背诵+错题复习+模拟） （25 ONE ONE）</p><p>马原32思修12史纲21毛中特27（每个半小时）</p><p>高数强化36（每个50min左右，30小时左右）</p><p>线代强化11（每个2h）</p><p>阅读技巧10（每个2h）</p><p>写作基础19强化21（可以再看看其他的）</p><p>翻译基础21强化10</p><p>新题型</p><p>完型</p><hr><h3 id="ATTENTION："><a href="#ATTENTION：" class="headerlink" title="ATTENTION："></a>ATTENTION：</h3><p>理论基本构建完毕，坑也基本填完了。是时候结束假期了，开始构筑自律循环，拿到入场券，进入下一个阶段。</p><p>开始进入<strong>认真模式（无论什么情况，任务都必须按时完成）</strong></p><h3 id="2-α（拼命阶段，必须坚持到底）"><a href="#2-α（拼命阶段，必须坚持到底）" class="headerlink" title="2-α（拼命阶段，必须坚持到底）"></a>2-α（拼命阶段，必须坚持到底）</h3><h3 id="10-1-Rush计划（10-1-10-10）"><a href="#10-1-Rush计划（10-1-10-10）" class="headerlink" title="10.1 Rush计划（10.1-10.10）"></a>10.1 Rush计划（10.1-10.10）</h3><p><strong>数学：</strong>每天完成一个章节的课程（每天看5个）和笔记</p><p>一个章节基础篇的归纳整理</p><p>剩余没做完的一个章节的题目以及改错（工作量超大）（10.8前必须把所有都完成）</p><p><strong>专业课：</strong>第一天完成cpu和第六章和部分第七章，第二天把计组结束，然后把操作系统第一章搞完，之后每天一章操作系统或者计网，预计到10月10号搞定这一遍</p><p><strong>英语：</strong>第一天把之前做的题目综合整理一遍，背诵一遍。</p><p>（完成阅读方法和计划的调整）</p><p><strong>（词汇+语法+逻辑+精准训练）-&gt; 阅读质变</strong></p><p>从这次之后每天至少400单词复习，必有100新单词的复习</p><p>每一周完整复习一遍语法以及对于阅读的整理，长难句的分析</p><p>到16号之前每天半个阅读的逻辑</p><p>每天两篇阅读加整理和分析（A词汇整理  B注意长难句和段落的分析  C题目的分析，注意回归原文的方法，培养意识）（把手头英一的题目做完，之后10天做英二的（头五年），剩下的阅读留着之后看小三门的时候每两天一篇（应该还剩下五年的英一和六年的英二））</p><p><strong>政治：</strong>按照原计划执行，10月10号左右完成马原和思修的所有内容</p>]]></content>
    
    
    
    <tags>
      
      <tag>考研准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目开发踩坑日志(+1)</title>
    <link href="/2020/02/24/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E6%97%A5%E5%BF%97-1/"/>
    <url>/2020/02/24/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E6%97%A5%E5%BF%97-1/</url>
    
    <content type="html"><![CDATA[<h2 id="项目开发踩坑日志-1"><a href="#项目开发踩坑日志-1" class="headerlink" title="项目开发踩坑日志(+1)"></a>项目开发踩坑日志(+1)</h2><p>十分不情愿的开始了项目开发的工作……</p><h3 id="研究生论文送审平台（学院专家管理模块）"><a href="#研究生论文送审平台（学院专家管理模块）" class="headerlink" title="研究生论文送审平台（学院专家管理模块）"></a>研究生论文送审平台（学院专家管理模块）</h3><p>花费了完全三天时间完成 项目的 理解分析  代码编写  测试修改并最终验收</p><p>主要功能工作包括 1 基础功能  2 三个附加功能 3 权限与测试</p><h3 id="1-基础功能开放踩坑"><a href="#1-基础功能开放踩坑" class="headerlink" title="1 基础功能开放踩坑"></a>1 基础功能开放踩坑</h3><p>表单配置</p><p>代码生成</p><p>权限配置</p><p>grid选择框（这个是真的坑，要从mapper一路改到前端）</p><ul><li>前端的属性通过封装的直接去别的模块的mapper去取，千万别写错路径</li><li>后端mapper保存的时候也是，注意要改 别名 leftjoin findlist insert 以及update</li></ul><p>一些细节的修改</p><h3 id="2-三个附加功能"><a href="#2-三个附加功能" class="headerlink" title="2 三个附加功能"></a>2 三个附加功能</h3><p>A 根据登录账号秘书身份筛选数据</p><p>B 新增专家的时候根据账号信息去查找相关秘书的信息，填充秘书代码以及高校代码+学院代码字段</p><p>C 在新增专家时，在sys_userz中自动生成一个可登陆的专家用户，并指定权限与身份</p><h3 id="3-权限与测试"><a href="#3-权限与测试" class="headerlink" title="3 权限与测试"></a>3 权限与测试</h3><p>测试碰到了许许多多数据库字段以及权限相关的报错，都一一解决了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个项目坑的地方在于，一茬一茬的人写，留下了一路的坑，有很多模块很多人重复开发过，实际情况与设计文档严重不符，存在各种各样奇奇怪怪的表和模块，都不知道要加的这个模块的数据要和哪些模块做关联，其他模块又是怎么工作的，只能自己去看代码理解，估摸着写，估摸着测试，碰到坑就重新写，磕磕绊绊总算是搞定了。模块本身从功能上来说并不是太难，主要是项目管控和开发测试的管理做的太差，文档留的太少，很多都是口头约定然后修改的，为后续模块开发带来了大量困难。从这种事件中可以看出，一个好的工程管理的重要性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习算法的一点思路</title>
    <link href="/2020/02/19/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%B7%AF/"/>
    <url>/2020/02/19/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="关于学习算法的一点思考"><a href="#关于学习算法的一点思考" class="headerlink" title="关于学习算法的一点思考"></a>关于学习算法的一点思考</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><hr><p>作为一个技术狗，数据结构和算法的重要性是毋庸置疑的<del>（比如说像我一样在项目里写各种鸡肋实现方式的时候，你就会体会到这玩意的重要性了）</del>。所以，痛定思痛，决定扎扎实实的把这一块掌握起来，包括但不限于算法的原理，实现方式以及各种应用。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><hr><p>对于算法的学习，打算从两条线入手，<strong>自顶向下和自底向上</strong>。自顶向下就是从数据结构和算法的书籍入手，一点一点啃，逐步建立起算法的知识体系，即有一个完整而清晰地框架，每个算法的原理，实现方式，以及各个算法之间的联系与区别。而自底向上则是从算法题入手，无论是在LeetCode也好，PAT也好，通过解题来学习算法的应用，思路，从而可以在开发中熟练应用各种算法的知识<del>（当然，从功利角度来说，无论是考研复试还是找工作，算法题是你永远绕不开的坎）</del>。</p><p><strong>而对于算法的训练，应当成为每一个开发者的日常习惯，就如同吃饭喝水一样。</strong>只有日复一日的持续学习，思考，编码过程中，才能将一项技能彻底掌握。当然，并不是说要求每天成小时的使劲做，而是细水长流，每天可以来上几道题，什么时候做都可以，早上起来，午饭后，甚至排队，<del>蹲坑</del>的时候都可以想，可以做，让它成为你生活的一部分，一个习惯。基于以上思考，<strong>计划两天学习一章的算法，每天两道PAT，两道LeetCode（PAT平推，LeetCode每周选一种类型进行刷题）</strong>。</p><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><hr><p>而刷算法的思路有了，再说一下方式。</p><p>对于自顶向下来说，相当于课程的学习，逐步推进，没有什么特别要说的，按照三个步骤</p><ul><li><strong>（1）根据书来学习和理解算法</strong></li><li><strong>（2）将算法的原理和思路整理在本子上</strong></li><li><strong>（3）独立的将这个算法及相关编码实现</strong></li></ul><p>对于自底向上，要稍微复杂一点，大致为四个步骤</p><ul><li><p><strong>（1）首先分析问题，确定题目的需求（尤其英文题目，一定要看清楚），分析思路，选择对应的算法</strong></p></li><li><p><strong>（2）查找相应的数据结构与算法，进行学习记录，达到可以独立实现的程度（如果是兔系刷题方式可合并到（3）后）</strong></p></li><li><p><strong>（3）编码实现，有两种方式，第一个是兔系刷题方式</strong></p><ul><li><strong>（a）先去看大佬们的答案，理解代码，整理思路</strong></li><li><strong>（b）然后自己独立的实现一遍，注意比对差距并完善</strong></li></ul><p>​         <strong>另一种是龟系刷题方式</strong></p><ul><li><strong>（a）不论多难，自己来写<del>（实在不会看看也可）</del></strong></li><li><strong>（b）再找大佬的解答不断对比，找差距，完善自己的代码和意识</strong></li></ul></li><li><p><strong>（4）整理题目，包括分析，思路，编码过程等等，整理成Markdown形式，上传到自己的Blog</strong></p><p>（对于具体如何刷题，可以进一步参考知乎大佬们的回答 -&gt; <a href="https://www.zhihu.com/question/280279208/answer/499663699" target="_blank" rel="noopener">胖君</a>）</p></li></ul><p>以上，希望自己可以按照这个思路坚持下来，有所收获。</p><blockquote><p>（1/6 β Project）</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT-A1003 Emergency</title>
    <link href="/2020/02/18/PAT-A1003-Emergency/"/>
    <url>/2020/02/18/PAT-A1003-Emergency/</url>
    
    <content type="html"><![CDATA[<h2 id="A1003-Emergency-（Dijkstra算法）"><a href="#A1003-Emergency-（Dijkstra算法）" class="headerlink" title="A1003 Emergency （Dijkstra算法）"></a>A1003 Emergency （Dijkstra算法）</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p><ul><li>Input Specification:</li></ul><p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: <em>N</em> (≤500) - the number of cities (and the cities are numbered from 0 to <em>N</em>−1), <em>M</em> - the number of roads, <em>C</em>1 and <em>C</em>2 - the cities that you are currently in and that you must save, respectively. The next line contains <em>N</em> integers, where the <em>i</em>-th integer is the number of rescue teams in the <em>i</em>-th city. Then <em>M</em> lines follow, each describes a road with three integers <em>c</em>1, <em>c</em>2 and <em>L</em>, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from <em>C</em>1 to <em>C</em>2.</p><ul><li>Output Specification:</li></ul><p>For each test case, print in one line two numbers: the number of different shortest paths between <em>C</em>1 and <em>C</em>2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p><ul><li>Sample Input:</li></ul><pre><code class="in">5 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1</code></pre><ul><li>Sample Output:</li></ul><pre><code class="out">2 4</code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这道题是经典的Dijkstra算法的应用，在求最短路径的基础上多求了最短路径条数以及最短路径的最大点权，难度不大<del>（本喵太菜所以还是做了好久）</del></p><p>Dijkstra算法的核心就在于在n次遍历中，（1）遍历所有点根据最短路径增加点集，（2）以及增加完点集后遍历所有点来更新c1到达每个点的最短路径*<em>(dis[u] + e[u][v] &lt; dis[v]) *</em>。而本题中还要求的最短路径条数和在此基础上最大救援队数目，在（2）的里面加一个判断即可实现</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, c1, c2;//邻接矩阵（边和边权） 点权  c1到任意一点的最短长度  c1到任意一点的最短路径的条数  c1到任意一点的救援队数目之和int e[500][500], weight[500], dis[500], num[500], w[500];bool visit[510];//作为点的集合const int inf = 999999;int main(){    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;c1, &amp;c2);    for (int i = 0; i &lt; n; i++)    {        scanf(&quot;%d&quot;, &amp;weight[i]);    }    fill(e[0], e[0] + 500 * 500, inf);    fill(dis, dis + 500, inf);    //初始化邻接矩阵    int a, b, c;    for (int i = 0; i &lt; m; i++)    {        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        e[a][b] = e[b][a] = c;    }    //初始化c1    dis[c1] = 0;    w[c1] = weight[c1];    num[c1] = 1;    for (int i = 0; i &lt; n; i++)    {        int u = -1;        int minn = inf;        //遍历所有点，找到到c1路径最短的那个点，加入到点集，直到遍历完所有点为止        for (int j = 0; j &lt; n; j++)        {   //从c1开始            if(visit[j] == false &amp;&amp; dis[j] &lt; minn){                u = j;                minn = dis[j];            }        }        if (u == -1) break;        visit[u] = true;        //在点集加了一个点之后，遍历所有点，更新c1到所有点的最短路径        for (int v = 0; v &lt; n; v++)        {   //如果新点与该点有边            if (visit[v] == false &amp;&amp; e[u][v] != inf)            {   //如果新点到任一点的距离比原来小，就更新dis                if (dis[u] + e[u][v] &lt; dis[v])                {                    dis[v] = dis[u] + e[u][v];                    num[v] = num[u]; //c1到达新点的最短路径条数应该与与他联通的v点相同                    w[v] = w[u] + weight[v];                }                else if (dis[u] + e[u][v] == dis[v])                {                    num[v] = num[v] + num[u];//新点不变，v点加上刚联通的u点的最短路径条数                    if (w[u] + weight[v] &gt; w[v])//如果这条路上的救援队数目更多，就更新                    {                        w[v] = w[u] + weight[v];                    }                }            }        }    }    printf(&quot;%d %d&quot;,num[c2],w[c2]);    return 0;}</code></pre><p>(解题时参考了柳婼大大的代码 有兴趣可以去看一下  -&gt; <a href="https://www.liuchuo.net/" target="_blank" rel="noopener">柳婼のBlog</a>)</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT-A1002 A+B for Polynomials</title>
    <link href="/2020/02/18/PAT-A1002-A-B-for-Polynomials/"/>
    <url>/2020/02/18/PAT-A1002-A-B-for-Polynomials/</url>
    
    <content type="html"><![CDATA[<h2 id="A1002-A-B-for-Polynomials（模拟）"><a href="#A1002-A-B-for-Polynomials（模拟）" class="headerlink" title="A1002 A+B for Polynomials（模拟）"></a>A1002 A+B for Polynomials（模拟）</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>This time, you are supposed to find <em>A</em>+<em>B</em> where <em>A</em> and <em>B</em> are two polynomials.</p><ul><li>Input Specification:</li></ul><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p><p><em>K</em> <em>N</em>1 <em>a<strong>N<em>1 *N</em>2 *a</strong>N<em>2 … <em>N</em></em>K</em> <em>a<strong>N</strong>K</em></p><p>where <em>K</em> is the number of nonzero terms in the polynomial, <em>N**i</em> and <em>a<strong>N</strong>i</em> (<em>i</em>=1,2,⋯,<em>K</em>) are the exponents and coefficients, respectively. It is given that 1≤<em>K</em>≤10，0≤<em>N**K</em>&lt;⋯&lt;<em>N</em>2&lt;<em>N</em>1≤1000.</p><ul><li>Output Specification:</li></ul><p>For each test case you should output the sum of <em>A</em> and <em>B</em> in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p><ul><li>Sample Input:</li></ul><pre><code class="in">2 1 2.4 0 3.22 2 1.5 1 0.5</code></pre><ul><li>Sample Output:</li></ul><pre><code class="out">3 2 1.5 1 2.9 0 3.2</code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>模拟两个多项式相加并输出结果</p><p>用一个数组来存储多项式的系数，输入哪一项的值，就加到哪一项</p><p>遍历一遍得到多项式的个数</p><p>遍历一遍输出多项式</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main(){    float c[1001] = {0};    int m,n,t;    float num;    scanf(&quot;%d&quot;,&amp;m);    for (int i = 0; i &lt; m; i++)    {        scanf(&quot;%d%f&quot;, &amp;t , &amp;num);        c[t] += num;    }    scanf(&quot;%d&quot;,&amp;n);    for (int i = 0; i &lt; n; i++)    {        scanf(&quot;%d%f&quot;,&amp;t,&amp;num);        c[t] += num;    }    int cnt = 0;    for (int i = 0; i &lt; 1001; i++)    {        if (c[i] != 0)        {            cnt++;        }    }    printf(&quot;%d&quot;,cnt);    for (int i = 1000; i &gt;= 0; i--)    {        if (c[i] != 0.0)        {            printf(&quot; %d %.1f&quot;, i, c[i]);        }    }    return 0;}</code></pre><p>(解题时参考了柳婼大大的代码 有兴趣可以去看一下  -&gt; <a href="https://www.liuchuo.net/" target="_blank" rel="noopener">柳婼のBlog</a>)</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT-A1001 A+B Format</title>
    <link href="/2020/02/18/PAT-A1001-A-B-Format/"/>
    <url>/2020/02/18/PAT-A1001-A-B-Format/</url>
    
    <content type="html"><![CDATA[<h2 id="A1001-A-B-Format（字符串处理）"><a href="#A1001-A-B-Format（字符串处理）" class="headerlink" title="A1001 A+B Format（字符串处理）"></a>A1001 A+B Format（字符串处理）</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Calculate <em>a</em>+<em>b</em> and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><ul><li>Input Specification: </li></ul><p>Each input file contains one test case. Each case contains a pair of integers <em>a</em> and <em>b</em> where −106≤<em>a</em>,<em>b</em>≤106. The numbers are separated by a space.</p><ul><li>Output Specification: </li></ul><p>For each test case, you should output the sum of <em>a</em> and <em>b</em> in one line. The sum must be written in the standard format.</p><ul><li>Sample Input:</li></ul><pre><code>-1000000 9</code></pre><ul><li>Sample Output:</li></ul><pre><code>-999,991</code></pre><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>将求和问题用字符串进行表示和处理是一种常规做法</p><p>即用 to_String(int) 进行转换</p><p>这一道题的关键在于 何时插入‘，’ 即从前往后输出 而又重后往前数数</p><p>((i + 1) % 3 == len % 3 &amp;&amp; i != len - 1)</p><p>用取余比对的方法来解决这个问题 即通过总长度得出余数 并且保证最后一位不会多输出</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main(){    int a,b;    cin &gt;&gt; a &gt;&gt; b;    string s = to_string(a + b);    int len = s.length();    for (int i = 0; i &lt; len; i++)    {        cout &lt;&lt; s[i];        if (s[i] == &#39;-&#39;) continue;        if ((i + 1) % 3 == len % 3 &amp;&amp; i != len - 1)        {            cout &lt;&lt; &quot;,&quot;;        }    }    return 0;}</code></pre><p>(解题时参考了柳婼大大的代码 有兴趣可以去看一下  -&gt; <a href="https://www.liuchuo.net/" target="_blank" rel="noopener">柳婼のBlog</a>)</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown使用指南</title>
    <link href="/2020/02/14/Markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2020/02/14/Markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="Markdown使用指南"><a href="#Markdown使用指南" class="headerlink" title="Markdown使用指南"></a>Markdown使用指南</h2><h3 id="α-对于文字的操作"><a href="#α-对于文字的操作" class="headerlink" title="α  对于文字的操作"></a>α  对于文字的操作</h3><p>** 中间的部分用粗体表示  如   <strong>我是一只喵</strong></p><p>*  中间的部分表示为斜体 如  <em>本喵想吃小鱼干了</em></p><p>~~ 中间的部分表示为删除线 如  <del>BUG改完了</del></p><p>\ 后加这些特殊符号表示转义，即不产生效果只显示本身符号</p><h3 id="β-对于段落的操作"><a href="#β-对于段落的操作" class="headerlink" title="β  对于段落的操作"></a>β  对于段落的操作</h3><p>1  几级标题就用几个#+标题文字 记得#与文字中间要加一个空格 如 </p><h3 id="看板喵-の-Blog"><a href="#看板喵-の-Blog" class="headerlink" title="看板喵 の Blog"></a>看板喵 の Blog</h3><p>2  &gt; 后的一段会变为引用 如</p><blockquote><p>快起床！BUG要改不完了！</p><p>喵！（炸毛）</p></blockquote><p>3  * 或+ 后的一段会加标识（本喵也不知道这叫什么，反正就这么个东西）</p><p>可以按Tab键进行分级</p><ul><li>喵喵要出去玩~<ul><li>喵喵回来了~</li></ul></li><li>喵喵又要出去玩了~</li></ul><p>4  插入表格</p><p>表格的基本格式</p><blockquote><p>| 喵喵爱吃的菜 | 喵喵不爱吃的零食 |</p><p>| : ————- | : ————- |</p><p>| 小鱼干 | 橘子 |</p><p>| 虾虾  | 干果 |</p></blockquote><p>Command+T 可以插入表格 (Typora)</p><p>5  分割线</p><p>*** 显示分割线</p><hr><p>本喵不喜欢改BUG！</p><hr><h3 id="γ-插入其他元素"><a href="#γ-插入其他元素" class="headerlink" title="γ  插入其他元素"></a>γ  插入其他元素</h3><p>1  插入链接的形式为 [要带链接的文字](网址)  </p><p><a href="https://missisolation.github.io/" target="_blank" rel="noopener">看板喵 の Blog</a></p><p>2  插入图片的形式为 ![图片的名字](图片的地址)</p><p><img src="/Users/apple/Documents/Blog/themes/fluid/source/img/cat.png" srcset="/img/loading.gif" alt="cat"></p><p>（Typora 直接把图片拖进来就可以）</p><p>3  代码框 与数学公式编辑</p><p>代码</p><p>用  `    ` 将代码部分括起来，形成显示代码的区域</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int n, m, c1, c2;int e[510][510], weight[510], dis[510], num[510], w[510];bool visit[510];const int inf = 99999999;int main(){    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;c1, &amp;c2);    for (int i = 0; i &lt; n; i++)    {        scanf(&quot;%d&quot;, &amp;weight[i]);    }        fill(e[0], e[0] + 510 * 510, inf);    return 0;}</code></pre><p>数学公式<br>$$<br>▽²ψ(x,y,z)+(8π²m/h²)[E-U(x,y,z)]ψ(x,y,z)＝0<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>开发工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Me - 日常</title>
    <link href="/2019/11/26/About-Me-%E6%97%A5%E5%B8%B8/"/>
    <url>/2019/11/26/About-Me-%E6%97%A5%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>The game has begun . . .</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
